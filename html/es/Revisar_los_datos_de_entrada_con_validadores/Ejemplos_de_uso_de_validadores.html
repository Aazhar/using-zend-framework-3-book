<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="description" content="A free, read-frendly and open-source book on ZF3">
<meta name="keywords" content="zend framework,book,beginner,free">
<meta name="author" content="2019 by Oleg Krivtsov">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="../../favicon.ico" rel="shortcut icon" type="image/ico" />
<link href="../../assets/css/style.css" type="text/css" rel="stylesheet" />
<title>Ejemplos de uso de validadores &ndash; Using Zend Framework 3</title>
</head>
<body>
<header>
    <div class="header">
        <div class="header-body">
            <div class="book-title">
                <a href="../../index.html">Using Zend Framework 3</a>
            </div>
            <div class="book-subtitle">
                A free, read-frendly and open-source book on ZF3            </div>
            <nav>
                <div class="menu">
                                        <div class="link">
                        <a href="https://olegkrivtsov.github.io/using-zend-framework-3-book/html">Home</a>
                    </div>
                                        <div class="link">
                        <a href="https://github.com/olegkrivtsov/using-zf3-book-samples">Samples</a>
                    </div>
                                        <div class="link">
                        <a href="https://olegkrivtsov.github.io/zf3-api-reference/html/">Class Reference</a>
                    </div>
                                        <div class="link">
                        <a href="https://github.com/olegkrivtsov/using-zend-framework-3-book">Contribute</a>
                    </div>
                    
                </div>
            </nav>
        </div>    
    </div>
</header>    
<div id="container">
<!-- Navigation -->
<div class="navigation">
    <div class="prev-chapter">
        
        <a href="../Revisar_los_datos_de_entrada_con_validadores/El_administrador_de_complementos_para_validadores.html">
            <img alt="Previous Chapter" src="../../assets/images/left.png"><span class="nav-btn-text">Previous</span>
        </a>
        </div>    
    <div class="contents">
        <a href="../toc.html">
            <img alt="Contents" src="../../assets/images/book.png"><span class="nav-btn-text">Contents</span>
        </a>
    </div>
    <div class="next-chapter">
                <a href="../Revisar_los_datos_de_entrada_con_validadores/Escribir_nuestro_propio_validador.html">
            <span class="nav-btn-text">Next</span><img alt="Next Chapter" src="../../assets/images/right.png">
        </a>
            </div>
        <div class="current-chapter">
        <a href="../Revisar_los_datos_de_entrada_con_validadores.html">
            <img alt="Contents" src="../../assets/images/upload.png"><span class="nav-btn-text">Revisar los datos de entrada con validadores</span>
        </a>
    </div>
    </div>

﻿<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Using Zend Framework 3 Book - Chapter - Adaptive -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3933778336056438"
     data-ad-slot="4531860323"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!-- Chapter content -->
<div id="chapter_content">
<div class="incomplete-translation">
    Translation into this language is not yet finished. You can help this project 
    by translating the chapters and contributing your changes.
</div>

<h2 id="Ejemplos_de_uso_de_validadores">9.6. Ejemplos de uso de validadores</h2>
<p>Ahora consideraremos el uso de los más importantes validadores estándares. Describiremos
los métodos y las opciones que tiene el validador y daremos un ejemplo que muestra
como instanciar y aplicar el validador a los datos de entrada.</p>
<h3 id="Validadores_para_revisar_la_conformidad_de_un_valor_a_un_formato_determinado">9.6.1. Validadores para revisar la conformidad de un valor a un formato determinado</h3>
<p>En esta sección, consideraremos ejemplos de uso de los validadores del grupo
de validadores diseñados para revisar si los valores de entrada se ajustan a un
formato determinado.</p>
<h4 id="Validador_Ip">9.6.1.1. Validador Ip</h4>
<p>La clase de validación <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Ip.html" class="api-link">Ip</a></code> está diseñada para revisar si el valor de entrada es una
dirección IP valida. Si el valor de entrada es una dirección IPv4 <sup id="fnref:ipv4_address"><a href="#fn:ipv4_address" class="footnote-ref" rel="footnote">32</a></sup>,
IPv6 <sup id="fnref:ipv6_address"><a href="#fn:ipv6_address" class="footnote-ref" rel="footnote">33</a></sup>, IPvFuture <sup id="fnref:ipvfuture_address"><a href="#fn:ipvfuture_address" class="footnote-ref" rel="footnote">34</a></sup> o una IPv6 literal <sup id="fnref:ipv6literal_address"><a href="#fn:ipv6literal_address" class="footnote-ref" rel="footnote">35</a></sup>;
el validador regresara un booleano <code>true</code>, de lo contrario regresa <code>false</code>.
En caso de fallo los mensajes de error se pueden extraer con el método <code>getMessages()</code>
del validador.</p>
<footnotes id="fn:ipv4_address"><p><sup>32)</sup> Una dirección de Protocolo de Internet versión 4 (IPv4) consiste
en cuatro octetos separados por puntos, como «182.168.56.101».</p>
</footnotes>
<footnotes id="fn:ipv6_address"><p><sup>33)</sup> Una dirección de Protocolo de Internet versión 6 (IPv6) consiste
en ocho grupos de cuatro dígitos hexadecimales separados por
dos puntos, como «2001:0db8:85a3:0000:0000:8a2e:0370:7334».</p>
</footnotes>
<footnotes id="fn:ipvfuture_address"><p><sup>34)</sup> IPvFuture está definida sin rigor en la sección 3.2.2 del RFC 3986.</p>
</footnotes>
<footnotes id="fn:ipv6literal_address"><p><sup>35)</sup> Una dirección IPv6 literal es una modificación de una dirección
IPv6 para que pueda ser usada dentro de una URL. (El problema
con la dirección IPv6 original es que los caracteres «:»
y «.» son delimitadores en las URLs)</p>
</footnotes>
<p>Los métodos públicos provistos por el validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Ip.html" class="api-link">Ip</a></code> se listan en la tabla 9.3:</p>
<div class="table-wrapper">
<div class="table-caption">Tabla 9.3. Métodos públicos del validador IP</div><table>
<thead>
<tr>
<th> <em>Nombre del método</em>            </th>
<th> <em>Descripción</em>                                                 </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>__construct($options)</code>        </td>
<td>  Construye el validador. Acepta una lista de opciones.         </td>
</tr>
<tr>
<td> <code>isValid($value)</code>              </td>
<td> Regresa <code>true</code> si y solo si el valor es una dirección IP valida. </td>
</tr>
<tr>
<td> <code>getMessages()</code>                                                 </td>
<td> Si la validación falla, este método regresará un arreglo de     mensajes de error.                                            </td>
</tr>
<tr>
<td> <code>setOptions($options)</code>         </td>
<td> Indica las opciones del validador.                            </td>
</tr>
</tbody>
</table>
</div>
<p>El método <code>setOptions()</code> permite indicar los tipos de dirección IP permitidos:</p>
<ul>
<li><code>allowipv4</code> para permitir direcciones IPv4.</li>
<li><code>allowipv6</code> para permitir direcciones IPv6.</li>
<li><code>allowipvfuture</code> para permitir direcciones IPvFuture.</li>
<li><code>allowliteral</code> para permitir direcciones IPv6 literal.</li>
</ul>
<p>Por defecto todas las direcciones que se muestran arriba son permitidas con la
excepción de la dirección IPv6 literal.</p>
<p>Abajo tenemos un código de ejemplo que demuestra el uso del validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Ip.html" class="api-link">Ip</a></code>.</p>
<pre class=""><code class="language-php">&lt;?php
use Zend\Validator\Ip;

// Create Ip validator.
$validator = new Ip();

// Configure the validator.
$validator-&gt;setOptions([
    'allowipv4'      =&gt; true,  // Allow IPv4 addresses.
    'allowipv6'      =&gt; true,  // Allow IPv6 addresses.
    'allowipvfuture' =&gt; false, // Allow IPvFuture addresses.
    'allowliteral'   =&gt; true,  // Allow IP addresses in literal format.
  ]);

// Check if input value is a valid IP address (IPv4).
$isValid = $validator-&gt;isValid('192.168.56.101'); // Returns true

// Check if input value is a valid IP address (IPv6).
$isValid2 = $validator-&gt;isValid(
       '2001:0db8:85a3:0000:0000:8a2e:0370:7334'); // Returns true

// Pass an invalid string (not containing an IP address).
$isValid3 = $validator-&gt;isValid('abc'); // Returns false
</code></pre>
<h4 id="Validador_Hostname">9.6.1.2. Validador Hostname</h4>
<p>El validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Hostname.html" class="api-link">Hostname</a></code> está diseñado para revisar si el valor dado es un nombre
de servidor que pertenece al conjunto de tipos de nombres de servidor permitidos.
Los tipos son:</p>
<ul>
<li>Un nombre de servidor DNS (ejemplo, «example.com»);</li>
<li>Una dirección IP (ejemplo, «192.168.56.101»);</li>
<li>Un nombre de servidor local (ejemplo, «localhost»).</li>
</ul>
<p>Los métodos públicos provistos por el validador se listan en la tabla 9.4:</p>
<div class="table-wrapper">
<div class="table-caption">Tabla 9.4. Métodos públicos del validador Hostname</div><table>
<thead>
<tr>
<th> <em>Nombre del método</em>            </th>
<th> <em>Descripción</em>                                                 </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>__construct($options)</code>        </td>
<td>  Construye el validador. Acepta una lista de opciones.         </td>
</tr>
<tr>
<td> <code>isValid($value)</code>                                               </td>
<td> Regresa <code>true</code> cuando el valor es un nombre de servidor valido  , de lo contrario regresa <code>false</code>.                            </td>
</tr>
<tr>
<td> <code>getMessages()</code>                                                 </td>
<td> Si la validación falla, el método regresará un arreglo de       mensajes de error.                                            </td>
</tr>
<tr>
<td> <code>setIpValidator($ipValidator)</code>                                  </td>
<td> Opcionalmente, permite colocar nuestro propio validador de      dirección IP.                                                 </td>
</tr>
<tr>
<td> <code>getIpValidator()</code>             </td>
<td> Recupera el validador de dirección IP añadido.                </td>
</tr>
<tr>
<td> <code>setAllow()</code>                   </td>
<td> Define el o los tipos de nombres de servidor permitidos.      </td>
</tr>
<tr>
<td> <code>getAllow()</code>                   </td>
<td> Regresa los tipos de nombre de servidor permitidos.           </td>
</tr>
<tr>
<td> <code>useIdnCheck()</code>                                                 </td>
<td> Define si la revisión del Nombre de Dominio Internacionalizado  (IDN) está habilitado. La opción por defecto es <code>true</code>.       </td>
</tr>
<tr>
<td> <code>getIdnCheck()</code>                </td>
<td> Regresa <code>true</code> si la revisión IDN está habilitada.            </td>
</tr>
<tr>
<td> <code>useTldCheck()</code>                                                 </td>
<td> Define si la revisión de Dominio de Nivel Superior (TLD) está   habilitada. Esta opción por defecto es <code>true</code>.                </td>
</tr>
<tr>
<td> <code>getTldCheck()</code>                </td>
<td> Regresa <code>true</code> si la revisión TLD está activada.              </td>
</tr>
</tbody>
</table>
</div>
<p>Podemos indicar los nombres de los tipos de servidor permitidos con el método <code>setAllow()</code>.
Este método acepta la combinación de las siguientes constantes:</p>
<ul>
<li><code>ALLOW_DNS</code> permite nombres de dominio de Internet (ejemplo, <em>example.com</em>).</li>
<li><code>ALLOW_IP</code>  permite direcciones IP.</li>
<li><code>ALLOW_LOCAL</code> permite nombres locales de red (ejemplo, <em>localhost</em>, <em>www.localdomain</em>);</li>
<li><code>ALLOW_URI</code> permite nombre URI de servidor.</li>
<li><code>ALLOW_ALL</code> permite todos los tipos de nombre de servidor.</li>
</ul>
<p>Por defecto, solo se permiten los nombre de dominio de Internet.</p>
<p>La revisión del nombre de servidor consiste de varias etapas, algunas se pueden
omitir dependiendo de las opciones del validador:</p>
<ol>
<li><p>Si el valor de entrada se parece a una dirección IP, esta se revisa con el validador
de direcciones IP interno. Podemos sobrescribir el validador de direcciones IP
con el método <code>setIpValidator()</code>.</p>
</li>
<li><p>El nombre del servidor se separa dejando la parte del dominio (con el separador
«.»).</p>
</li>
<li><p>El dominio de primer nivel se revisa contra la lista blanca con los TLDs permitidos.
(Podemos desactivar esta revisión con el método <code>useTldCheck()</code>).</p>
</li>
<li><p>La parte de dominio se revisa en base a las reglas de nombres de dominio aceptables.
Si un nombre de dominio es un IDN <sup id="fnref:idn"><a href="#fn:idn" class="footnote-ref" rel="footnote">36</a></sup> se revisa contra las reglas para
validar IDNs. (Podemos desactivar la revisión IDN con el método <code>useIdnCheck()</code>).</p>
</li>
</ol>
<footnotes id="fn:idn"><p><sup>36)</sup> Un Nombre de Dominio Internacionalizado (IDN) es un nombre de dominio de
Internet que contiene al menos una letra en un alfabeto específico como
en el Árabe, Chino o Ruso.</p>
</footnotes>
<p>Abajo, mostramos un código de ejemplo que demuestra el uso del validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Hostname.html" class="api-link">Hostname</a></code>.</p>
<pre class=""><code class="language-php">&lt;?php
use Zend\Validator\Hostname;

// Create the Hostname validator.
$validator = new Hostname();

// Configure the validator.
$validator-&gt;setAllow(Hostname::ALLOW_DNS|Hostname::ALLOW_IP);

// Check a host name.
$isValid = $validator-&gt;isValid('site1.example.com');
// Returns true.
$isValid2 = $validator-&gt;isValid('abc');
// Returns false (not a valid host name).
</code></pre>
<h4 id="El_validador_Uri">9.6.1.3. El validador Uri</h4>
<p>El validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Uri.html" class="api-link">Uri</a></code> está diseñado para revisar si el valor de entrada es un
Identificador de Recursos Uniforme (URI) <sup id="fnref:uri"><a href="#fn:uri" class="footnote-ref" rel="footnote">37</a></sup>. En caso de falla los mensajes
de error se pueden recuperar con el método del validador <code>getMessages()</code>.</p>
<blockquote class="notquote information" data-type="information"><p> No nos confundamos con el termino URI. En la mayoría de los casos podemos
 pensar a la URI como un URL usual.</p>
</blockquote><footnotes id="fn:uri"><p><sup>37)</sup> Un Identificador de Recursos Uniforme (URI) es una secuencia compacta
de caracteres que identifica un recurso abstracto o físico. Un Localizador
Uniforme de recursos (URL) es un tipo de URI. Pero, no todas las URIs son
URLs.</p>
</footnotes>
<p>Los métodos públicos que provee el validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Uri.html" class="api-link">Uri</a></code> se listan en la tabla 9.5:</p>
<div class="table-wrapper">
<div class="table-caption">Table 9.5. Public methods of the Uri validator</div><table>
<thead>
<tr>
<th> <em>Nombre del método</em>            </th>
<th> <em>Descripción</em>                                                 </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>__construct($options)</code>        </td>
<td>  Construye el validador. Acepta una lista de opciones.         </td>
</tr>
<tr>
<td> <code>isValid($value)</code>                                               </td>
<td> Regresa <code>true</code> cuando el valor es una URI valida, de lo         regresa <code>false</code>.                                              </td>
</tr>
<tr>
<td> <code>getMessages()</code>                                                 </td>
<td> Si la validación falla, este método regresa un arreglo de       mensajes de error.                                            </td>
</tr>
<tr>
<td> <code>setUriHandler($uriHandler)</code>   </td>
<td> Asigna el gestos de objetos URI para este validador.          </td>
</tr>
<tr>
<td> <code>getUriHandler()</code>              </td>
<td> Recupera el gestos de objetos URI.                            </td>
</tr>
<tr>
<td> <code>setAllowAbsolute($allowAbsolute)</code></td>
<td> Indica al validador si se aceptan las URI absolutas.       </td>
</tr>
<tr>
<td> <code>getAllowAbsolute()</code>           </td>
<td> Regresa <code>true</code> si se aceptan las URI absolutas.               </td>
</tr>
<tr>
<td> <code>setAllowRelative($allowRelative)</code></td>
<td> Le dice al validador si se aceptan las URI relativas.      </td>
</tr>
<tr>
<td> <code>getAllowRelative()</code>           </td>
<td> Regresa <code>true</code> si se aceptan las URIs relativas.              </td>
</tr>
</tbody>
</table>
</div>
<p>Internamente, el validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Uri.html" class="api-link">Uri</a></code> usa el <em>gestor de objetos URI</em> (URI handler object)
que es responsable de analizar la cadena de caracteres de la URI. Por defecto, la
clase <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Uri/Uri.html" class="api-link">Zend\Uri\Uri</a></code> se usa como gestor de URI. (Si queremos, podemos colocar nuestro
gestor de URI personalizado con el método <code>setUriHandler()</code>).</p>
<p>Una URI puede ser absoluta o relativa. Por ejemplo, una URI absoluta es
«http://example.com/blog/2014/02/02/edit», mientras que una relativa es
«2014/02/02/edit». Podemos especificar si el validador considera aceptables a las
URIs relativas, a las absolutas o ambas. Para esto, usamos los métodos
<code>setAllowAbsolute()</code> and <code>setAllowRelative()</code>, respectivamente. Por defecto, ambas
son tratadas como tipos de URI aceptables.</p>
<p>Abajo, un código de ejemplo muestra el uso del validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Uri.html" class="api-link">Uri</a></code>.</p>
<pre class=""><code class="language-php">&lt;?php
use Zend\Validator\Uri;

// Create the Uri validator.
$validator = new Uri();

// Configure the validator.
$validator-&gt;setAllowAbsolute(true);
$validator-&gt;setAllowRelative(true);

// Check an URI.
$isValid = $validator-&gt;isValid('http://site1.example.com/application/index/index');
// Returns true.
$isValid2 = $validator-&gt;isValid('index/index');
// Returns true.
</code></pre>
<h4 id="El_validador_Date">9.6.1.4. El validador Date</h4>
<p>El validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Date.html" class="api-link">Date</a></code> está pensado para revisar si el dato de entrada es una fecha
en un formato dado. En caso de falla, los mensajes de error se pueden extraer con
el método del validador <code>getMessages()</code>.</p>
<p>Los métodos públicos que provee el validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Date.html" class="api-link">Date</a></code> se listan en la tabla 9.6:</p>
<div class="table-wrapper">
<div class="table-caption">Tabla 9.6. Métodos públicos del validador Date</div><table>
<thead>
<tr>
<th> <em>Nombre del método</em>            </th>
<th> <em>Descripción</em>                                                 </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>__construct($options)</code>        </td>
<td>  Construye el validador. Acepta una lista de opciones.         </td>
</tr>
<tr>
<td> <code>isValid($value)</code>                                                                                </td>
<td> Regresa <code>true</code> cuando el valor es una cadena de caracteres      que contiene una fecha en un formato esperado; de lo contrario  regresa <code>false</code>.                                              </td>
</tr>
<tr>
<td> <code>getMessages()</code>                                                 </td>
<td> Si la validación falla el método regresa un arreglo de          mensajes de error.                                            </td>
</tr>
<tr>
<td> <code>setFormat($format)</code>           </td>
<td> Coloca el formato de fecha aceptable.                         </td>
</tr>
<tr>
<td> <code>getFormat()</code>                  </td>
<td> Regresa el formato esperado.                                  </td>
</tr>
</tbody>
</table>
</div>
<p>Para colocar el formato de la fecha que se espera podemos usar el método <code>setFormat()</code>.</p>
<blockquote class="notquote information" data-type="information"><p> Internamente, el filtro <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Filter/DateTimeFormatter.html" class="api-link">DateTimeFormatter</a></code> usa la clase <code>DateTime</code> de la biblioteca
 estándar de PHP para convertir y formatear las fechas. Los formatos de fecha
 disponibles los podemos conseguir en la documentación de PHP de la clase <code>DateTime</code>.</p>
</blockquote><p>Abajo, un código de ejemplo demuestra el uso del validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Date.html" class="api-link">Date</a></code>.</p>
<pre class=""><code class="language-php">&lt;?php
use Zend\Validator\Date;

// Create validator instance.
$validator = new Date();

// Configure validator.
$validator-&gt;setFormat('Y-m-d');

// Check if the input value is a date having expected format.
$isValid = $validator-&gt;isValid('2014-04-04'); // Returns true.
$isValid2 = $validator-&gt;isValid('April 04, 2014'); // Returns false (format is unexpected).
</code></pre>
<h4 id="El_validador_Regex">9.6.1.5. El validador Regex</h4>
<p>Este validador nos permite validar si una cadena de caracteres dada cumple alguna
expresión regular. Regresa <code>true</code> si la cadena de caracteres coincide con la expresión
regular, de lo contrario regresa <code>false</code>. En caso de fallo, los mensajes de error
se pueden extraer con el método <code>getMessages()</code> del validador.</p>
<p>Los métodos públicos que provee el validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Regex.html" class="api-link">Regex</a></code> se listan en la tabla 9.7:</p>
<div class="table-wrapper">
<div class="table-caption">Tabla 9.7. Métodos públicos del validador Regex</div><table>
<thead>
<tr>
<th> <em>Nombre del método</em>            </th>
<th> <em>Descripción</em>                                                 </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>__construct($options)</code>        </td>
<td>  Construye el validador. Acepta una lista de opciones.         </td>
</tr>
<tr>
<td> <code>isValid($value)</code>                                               </td>
<td> Regresa <code>true</code> si y solo si <code>$value</code> coincide con el patrón     que resulta de la expresión regular dada.                     </td>
</tr>
<tr>
<td> <code>getMessages()</code>                                                 </td>
<td> Si la validación falla el método regresará un arreglo de        mensajes de error.                                            </td>
</tr>
<tr>
<td> <code>setPattern($pattern)</code>         </td>
<td> Asigna el patrón para expresión regular.                      </td>
</tr>
<tr>
<td> <code>getPattern()</code>                 </td>
<td> Recupera el patrón de la expresión regular.                   </td>
</tr>
</tbody>
</table>
</div>
<p>El método <code>setPattern()</code> permite colocar la expresión regular sobre la que se hace
la comparación.</p>
<blockquote class="notquote tip" data-type="tip"><p> Para conocer la sintaxis y ver ejemplos de las expresiones regulares recomendamos
 revisar la sección <em>Patrones PCRE</em> de la documentación de PHP.</p>
</blockquote><p>Abajo, con un código de ejemplo mostramos el uso del validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Regex.html" class="api-link">Regex</a></code>. En el ejemplo
usamos una expresión regular para revisar si la cadena de caracteres de entrada es
una dirección IPv4 valida (una dirección consiste típicamente consiste en cuatro
grupos de dígitos separados por puntos).</p>
<pre class=""><code class="language-php">&lt;?php
use Zend\Validator\Regex;

// Create Regex validator.
$validator = new Regex();

// Set regular expression to check for an IP address.
$validator-&gt;setPattern('\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b');

// Check for regular expression match.
$isValid = $validator-&gt;isValid("127.0.0.1"); // returns true.
$isValid2 = $validator-&gt;isValid("123"); // returns false.
</code></pre>
<h3 id="Validadores_para_revisar_si_un_valor_numérico_está_en_un_rango_dado">9.6.2. Validadores para revisar si un valor numérico está en un rango dado</h3>
<p>En esta sección consideraremos ejemplos de uso de validadores del grupo de validadores
diseñados para revisar si los datos de entrada están en un rango dado.</p>
<h4 id="Validador_NotEmpty">9.6.2.1. Validador NotEmpty</h4>
<p>El validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/NotEmpty.html" class="api-link">NotEmpty</a></code> permite revisar si el dato de entrada no está vacío.
Este validador es útil cuando se trabaja con elementos de formulario u otras
entradas de usuario, en donde podemos usarlo para asegurar que los elementos
obligatorios tienen valores asociados.</p>
<p>Los métodos públicos que provee el validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/NotEmpty.html" class="api-link">NotEmpty</a></code> se listan en la tabla 9.8:</p>
<div class="table-wrapper">
<div class="table-caption">Tabla 9.8. Métodos públicos del validador NotEmpty</div><table>
<thead>
<tr>
<th> <em>Nombre del método</em>            </th>
<th> <em>Descripción</em>                                                 </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>__construct($options)</code>        </td>
<td>  Construye el validador. Acepta una lista de opciones.         </td>
</tr>
<tr>
<td> <code>isValid($value)</code>              </td>
<td> Regresa <code>true</code> si y solo si <code>$value</code> no es un valor vacío.    </td>
</tr>
<tr>
<td> <code>getMessages()</code>                                                 </td>
<td> Si la validación falla, el método regresará un arreglo de       mensajes de error.                                            </td>
</tr>
<tr>
<td> <code>setType($type)</code>               </td>
<td> Coloca los tipos de valor que se consideran valores vacíos.   </td>
</tr>
<tr>
<td> <code>getType()</code>                    </td>
<td> Regresa los tipos.                                            </td>
</tr>
<tr>
<td> <code>getDefaultType()</code>             </td>
<td> Regresa los tipos por defectos.                               </td>
</tr>
</tbody>
</table>
</div>
<p>El método <code>setType()</code> específica que tipos de variables se consideran valores
vacíos. Este método acepta un solo argumento <code>$type</code> que puede ser o una combinación
OR de las constantes listadas en la tabla 9.9, o un arreglo que contenga los equivalentes
literales de estas constantes.</p>
<div class="table-wrapper">
<div class="table-caption">Tabla 9.9. Tipos de Constantes</div><table>
<thead>
<tr>
<th> <em>Constante</em>          </th>
<th> <em>Valor numérico</em>   </th>
<th> <em>Equivalente literal</em></th>
<th> <em>Descripción</em>                          </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>BOOLEAN</code>            </td>
<td>  1                  </td>
<td>  «boolean»            </td>
<td>  Considera al booleano <code>false</code> como un valor vacío.</td>
</tr>
<tr>
<td> <code>INTEGER</code>            </td>
<td> 2                  </td>
<td> «integer«            </td>
<td> Considera al entero 0 como un valor vacío.</td>
</tr>
<tr>
<td> <code>FLOAT</code>              </td>
<td> 4                  </td>
<td> «float»              </td>
<td> Considera al flotante 0.0 como un valor vacío.</td>
</tr>
<tr>
<td> <code>STRING</code>                                    </td>
<td> 8                                       </td>
<td> «string»                                    </td>
<td> Considera la cadena de caracteres vacía  '' como un valor vacío.                </td>
</tr>
<tr>
<td> <code>ZERO</code>                                                             </td>
<td> 16                                                           </td>
<td> «zero»                                                             </td>
<td> Considera a la cadena de caracteres que  contiene solamente el carácter cero      ('0') como un valor vacío.             </td>
</tr>
<tr>
<td> <code>EMPTY_ARRAY</code>        </td>
<td> 32                 </td>
<td> «array»              </td>
<td> Considera a un arreglo vacío como un valor vacío.</td>
</tr>
<tr>
<td> <code>NULL</code>               </td>
<td> 64                 </td>
<td> «null»               </td>
<td> Considera a <code>null</code> como un valor vacío.</td>
</tr>
<tr>
<td> <code>PHP</code>                                                              </td>
<td> 127                                                          </td>
<td> «php»                                                              </td>
<td> Considera vacío al valor si la función   de PHP <code>empty()</code> regresa <code>true</code> sobre    el valor.                              </td>
</tr>
<tr>
<td> <code>SPACE</code>                                                            </td>
<td> 128                                                          </td>
<td> «space»                                                            </td>
<td> Considera una cadena de caracteres como  un valor vacío si contiene solo espacios  en blanco.                             </td>
</tr>
<tr>
<td> <code>OBJECT</code>                                    </td>
<td> 256                                     </td>
<td> «object»                                    </td>
<td> Regresa <code>true</code>. Cuando un objeto no es   permitido pero es dado se regresa <code>false</code>.</td>
</tr>
<tr>
<td> <code>OBJECT_STRING</code>                                                    </td>
<td> 512                                                          </td>
<td> «objectstring»                                                     </td>
<td> Regresa <code>false</code> cuando se da un objeto   y su método <code>__toString()</code> regresa una   cadena de caracteres vacía.            </td>
</tr>
<tr>
<td> <code>OBJECT_COUNT</code>                                                     </td>
<td> 1024                                                         </td>
<td> «objectcount»                                                      </td>
<td> Regresa <code>false</code> si el objeto dado tiene  una interfaz <code>Countable</code> y su cuenta     es 0.                                  </td>
</tr>
<tr>
<td> <code>ALL</code>                </td>
<td> 2047               </td>
<td> «all»                </td>
<td> Considera vacío a todos los valores anteriores.</td>
</tr>
</tbody>
</table>
</div>
<p>Abajo, mostramos un código de ejemplo que demuestra el uso del validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/NotEmpty.html" class="api-link">NotEmpty</a></code>.</p>
<pre class=""><code class="language-php">&lt;?php
use Zend\Validator\NotEmpty;

// Create validator instance.
$validator = new NotEmpty();

// Configure validator.
$validator-&gt;setType(NotEmpty::ALL);

// Check if input value not empty.
$isValid1 = $validator-&gt;isValid('some string'); // returns true
$isValid2 = $validator-&gt;isValid(''); // returns false
$isValid3 = $validator-&gt;isValid(0); // returns false
</code></pre>
<h4 id="Validador_Between">9.6.2.2. Validador Between</h4>
<p>El validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Between.html" class="api-link">Between</a></code> revisa si un número está en un determinado rango (min, max),
incluyéndolos (por defecto) o excluyéndolos.</p>
<p>Los métodos públicos que provee el validador @<code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Between.html" class="api-link">Between</a></code> se listan en la tabla 9.10:</p>
<div class="table-wrapper">
<div class="table-caption">Tabla 9.10. Métodos públicos del validador Between</div><table>
<thead>
<tr>
<th> <em>Nombre del método</em>            </th>
<th> <em>Descripción</em>                                                 </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>__construct($options)</code>        </td>
<td>  Construye el validador. Acepta una lista de opciones.         </td>
</tr>
<tr>
<td> <code>isValid($value)</code>              </td>
<td> Regresa <code>true</code> si y solo si el valor está en el rango dado.   </td>
</tr>
<tr>
<td> <code>getMessages()</code>                                                 </td>
<td> Si el validador falla, el método regresará un arreglo de        mensajes de error.                                            </td>
</tr>
<tr>
<td> <code>setMin($min)</code>                 </td>
<td> Asigna el límite mínimo.                                      </td>
</tr>
<tr>
<td> <code>getMin()</code>                     </td>
<td> Recupera el límite mínimo.                                    </td>
</tr>
<tr>
<td> <code>setMax($max)</code>                 </td>
<td> Coloca el límite máximo.                                      </td>
</tr>
<tr>
<td> <code>getMax()</code>                     </td>
<td> Recupera el limite máximo.                                    </td>
</tr>
<tr>
<td> <code>setInclusive($inclusive)</code>     </td>
<td> Indica si la comparación se hace incluyendo los limites.      </td>
</tr>
<tr>
<td> <code>getInclusive()</code>               </td>
<td> Regresa la opción inclusiva.                                  </td>
</tr>
</tbody>
</table>
</div>
<p>El rango se puede colocar con los métodos <code>setMin()</code> y <code>setMax()</code>.</p>
<p>Por defecto el validador ejecuta una comparación inclusiva (para revisar si el valor
pertenece al rango dado, se compara si el valor es mayor o igual a su límite
inferior y si el valor es menor o igual a su límite superior). Se puede cambiar
este comportamiento con el método <code>setInclusive()</code>. Este le dice al validador
si ejecuta una comparación inclusiva (pasando <code>true</code> como argumento) o una
comparación exclusiva (pasando <code>false</code> como argumento).</p>
<p>Abajo, se muestra un ejemplo del uso del validador <code>Between</code>.</p>
<pre class=""><code class="language-php">&lt;?php
use Zend\Validator\Between;

// Create validator instance.
$validator = new Between();

// Configure validator.
$validator-&gt;setMin(1);
$validator-&gt;setMax(10);
$validator-&gt;setInclusive(true);

$isValid1 = $validator-&gt;isValid(5); // returns true.
$isValid2 = $validator-&gt;isValid(10); // returns true.
$isValid3 = $validator-&gt;isValid(0); // returns false (value is too small).
$isValid4 = $validator-&gt;isValid(15); // returns false (value is too big).
</code></pre>
<h4 id="Validador_InArray">9.6.2.3. Validador InArray</h4>
<p>El validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/InArray.html" class="api-link">InArray</a></code> revisa si el valor de entrada pertenece a un arreglo dado.
Los métodos públicos provistos por el validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/InArray.html" class="api-link">InArray</a></code> se listan en la tabla 9.11:</p>
<div class="table-wrapper">
<div class="table-caption">Tabla 9.11. Métodos públicos del validador InArray</div><table>
<thead>
<tr>
<th> <em>Nombre del método</em>            </th>
<th> <em>Descripción</em>                                                 </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>__construct($options)</code>        </td>
<td>  Construye el validador. Acepta una lista de opciones.         </td>
</tr>
<tr>
<td> <code>isValid($value)</code>              </td>
<td> Regresa <code>true</code> si y solo si el valor pertenece a un arreglo dado.</td>
</tr>
<tr>
<td> <code>getMessages()</code>                                                 </td>
<td> Si la validación falla, el método regresará un arreglo de       mensajes de error.                                            </td>
</tr>
<tr>
<td> <code>setHaystack($haystack)</code>       </td>
<td> Coloca el arreglo en el que buscar.                           </td>
</tr>
<tr>
<td> <code>getHaystack()</code>                </td>
<td> Regresa el arreglo de los valores permitidos.                 </td>
</tr>
<tr>
<td> <code>setStrict($strict)</code>           </td>
<td> Coloca el modo de comparación estricto.                       </td>
</tr>
<tr>
<td> <code>getStrict()</code>                  </td>
<td> Pregunta si el modo de comparación estricta está activado.    </td>
</tr>
<tr>
<td> <code>setRecursive($recursive)</code>     </td>
<td> Le dice al validador que busque recursivamente.               </td>
</tr>
<tr>
<td> <code>getRecursive()</code>               </td>
<td> Pregunta si la búsqueda recursiva está activada.              </td>
</tr>
</tbody>
</table>
</div>
<p>El método <code>setHaystack()</code> permite colocar el arreglo de valores permitidos.
El método <code>isValid()</code> buscará en el arreglo la presencia de <code>$value</code>.</p>
<p>Si el arreglo contiene valores anidados y queremos buscar en él recursivamente,
entonces usamos el método <code>setRecursive()</code>. Este método toma una bandera booleana.
Si la bandera es <code>true</code>, entonces la búsqueda sera ejecutada recursivamente, de
lo contrario los niveles anidados serán ignorados.</p>
<p>El método <code>setStrict()</code> provee la capacidad de decirle al validador como comparar
el valor de entrada y los valores en el arreglo. Este puede ser una combinación
de las siguientes constantes:</p>
<ul>
<li><code>COMPARE_NOT_STRICT</code> no ejecutar una revisión estricta del tipo de variable.</li>
<li><code>COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY</code> no ejecutar una revisión
estricta del tipo de variable, pero previene un falso positivo producto
de la comparación de una cadena de caracteres con un entero (por ejemplo, <code>"asdf" == 0</code>).
Esta es la opción por defecto.</li>
<li><code>COMPARE_STRICT</code> comparar tanto el tipo de variable como su valor.</li>
</ul>
<p>Abajo, demostramos con un ejemplo el uso del validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/InArray.html" class="api-link">InArray</a></code>.</p>
<pre class=""><code class="language-php">&lt;?php
use Zend\Validator\InArray;

// Create validator instance.
$validator = new InArray();

// Configure validator.
$validator-&gt;setHaystack([1, 3, 5]);

// Perform validation.
$isValid1 = $validator-&gt;isValid(1); // returns true.
$isValid2 = $validator-&gt;isValid(2); // returns false.
</code></pre>
<h4 id="Validador_StringLength">9.6.2.4. Validador StringLength</h4>
<p>El validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/StringLength.html" class="api-link">StringLength</a></code> revisa si la longitud de la cadena de caracteres de
entrada pertenece a un rango dado, incluyendo los extremos. Regresa <code>true</code> si
y solo si la longitud de la cadena de caracteres tiene el valor <code>min</code> y no es
mayor que la opción <code>max</code> (cuando la opción <code>max</code> no es nula).</p>
<p>Los métodos públicos que provee el validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/StringLength.html" class="api-link">StringLength</a></code> se listan en la tabla 9.12:</p>
<div class="table-wrapper">
<div class="table-caption">Tabla 9.12. Métodos públicos del validador StringLength</div><table>
<thead>
<tr>
<th> <em>Nombre del método</em>            </th>
<th> <em>Descripción</em>                                                 </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>__construct($options)</code>        </td>
<td>  Construye el validador. Acepta una lista de opciones.         </td>
</tr>
<tr>
<td> <code>isValid($value)</code>                                               </td>
<td> Regresa <code>true</code> si y solo si la longitud del valor está dentro   del rango dado.                                               </td>
</tr>
<tr>
<td> <code>getMessages()</code>                                                 </td>
<td> Si la validación falla, el método regresará un arreglo de       mensajes de error.                                            </td>
</tr>
<tr>
<td> <code>setMin($min)</code>                 </td>
<td> Coloca el límite mínimo.                                      </td>
</tr>
<tr>
<td> <code>getMin()</code>                     </td>
<td> Recupera el límite mínimo.                                    </td>
</tr>
<tr>
<td> <code>setMax($max)</code>                 </td>
<td> Coloca el limite máximo.                                      </td>
</tr>
<tr>
<td> <code>getMax()</code>                     </td>
<td> Recupera el límite máximo.                                    </td>
</tr>
<tr>
<td> <code>setEncoding($encoding)</code>       </td>
<td> Coloca la nueva codificación a usar.                          </td>
</tr>
<tr>
<td> <code>getEncoding()</code>                </td>
<td> Recupera la codificación.                                     </td>
</tr>
</tbody>
</table>
</div>
<p>Por defecto, el validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/StringLength.html" class="api-link">StringLength</a></code> no considera a ninguna cadena de caracteres
como valida. Usamos el método <code>setMin()</code> para indicar el limite inferior y el
método <code>setMax()</code> para indicar el limite superior de la longitud de la cadena
de caracteres permitida. Existen tres maneras posibles de hacer esto.</p>
<ul>
<li>Usar solamente el método <code>setMin()</code> para permitir cadenas de caracteres con
un limite inferior mínimo, pero sin limite de longitud superior.</li>
<li>Usar solo el método <code>setMax()</code> para permitir cadenas de caracteres con una
longitud mínima cero y una longitud máxima limite.</li>
<li>Usar ambos métodos, <code>setMin()</code> y <code>setMax()</code>, para permitir cadenas de caracteres
con un longitud entre el límite inferior y el superior.</li>
</ul>
<p>Por defecto, el motor de PHP usa codificación UTF-8 para las cadenas de caracteres.
Si nuestra cadena de caracteres de entrada usa una codificaciones diferente, debemos
especificarla con el método del validador <code>setEncoding()</code>.</p>
<p>Abajo, mostramos un código de ejemplo del uso del validador <code>StringLength</code>.</p>
<pre class=""><code class="language-php">&lt;?php
use Zend\Validator\StringLength;

// Create validator instance.
$validator = new StringLength();

// Configure the validator.
$validator-&gt;setMin(1);
$validator-&gt;setMax(10);

$isValid1 = $validator-&gt;isValid("string"); // returns true.
$isValid2 = $validator-&gt;isValid(""); // returns false (value is too short).
$isValid3 = $validator-&gt;isValid("a very long string"); // returns false (value is too long).
</code></pre>
<h3 id="Organizar_los_validadores_en_una_cadena">9.6.3. Organizar los validadores en una cadena</h3>
<p>Los validadores se pueden organizar en una cadena. Esto es posible con el
uso de la clase <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/ValidatorChain.html" class="api-link">ValidatorChain</a></code>. Cuando un validador compuesto se ejecuta,
el valor de entrada se pasa a cada validador por turno. El método
<code>isValid()</code> del validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/ValidatorChain.html" class="api-link">ValidatorChain</a></code> regresa <code>true</code> si todos los validadores
en la cadena regresan <code>true</code>, de lo contrario regresa <code>false</code>.</p>
<blockquote class="notquote information" data-type="information"><p> La clase <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/ValidatorChain.html" class="api-link">ValidatorChain</a></code> es usada
 internamente por la clase contenedor <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/InputFilter/InputFilter.html" class="api-link">InputFilter</a></code>
 para almacenar la secuencia de validadores asociados a un campo del modelo del
 formulario.</p>
</blockquote><p>Los métodos públicos que provee la clase <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/ValidatorChain.html" class="api-link">ValidadorChain</a></code>
se presentan en la tabla 9.13:</p>
<div class="table-wrapper">
<div class="table-caption">Tabla 9.13. Métodos públicos del validador ValidatorChain</div><table>
<thead>
<tr>
<th> <em>Nombre del método</em>            </th>
<th> <em>Descripción</em>                                                 </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>isValid($value)</code>              </td>
<td>  Regresa <code>true</code> si todos los validadores en la cadena regresan <code>true</code>.</td>
</tr>
<tr>
<td> <code>getMessages()</code>                </td>
<td> Regresa un arreglo con los mensajes de error de la validación.</td>
</tr>
<tr>
<td> <code>getValidators()</code>              </td>
<td> Regresa el arreglo de los validadores encadenados.            </td>
</tr>
<tr>
<td> <code>count()</code>                      </td>
<td> Regresa el total de validadores en la cadena.                 </td>
</tr>
<tr>
<td> <code>attach($validator, $breakChainOnFailure)</code> </td>
<td> Añade un validador al final de la cadena.         </td>
</tr>
<tr>
<td> <code>prependValidator($validator, $breakChainOnFailure)</code> </td>
<td> Añade un validador al principio de la cadena.</td>
</tr>
<tr>
<td> <code>attachByName($name, $options, $breakChainOnFailure)</code>                                                         </td>
<td> Usa el gestor de complementos para       agregar un valor a partir de su nombre.</td>
</tr>
<tr>
<td> <code>prependByName($name, $options, $breakChainOnFailure)</code>                                                                                                                   </td>
<td> Usar el gestor de complementos para     agregar al principio de la cadena un    validador por su nombre.              </td>
</tr>
<tr>
<td> <code>merge($validatorChain)</code>                                        </td>
<td> Mezcla la cadena de validación con un validador pasado como     parámetro.                                                    </td>
</tr>
</tbody>
</table>
</div>
<p>Un ejemplo de validadores en cadena se muestra en la figura 9.2. Consiste en el
validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/NotEmpty.html" class="api-link">NotEmpty</a></code> seguido por el validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/StringLength.html" class="api-link">StringLength</a></code> que a su vez está
seguido por el validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Date.html" class="api-link">Date</a></code>. Cuando esta cadena se ejecuta, primero, el
validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/NotEmpty.html" class="api-link">NotEmpty</a></code> revisa que el valor no sea un valor vacío, luego el validador
<code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/StringLength.html" class="api-link">StringLength</a></code> revisa que la longitud de la cadena de caracteres este en el rango
(1, 16); ambos inclusive; y finalmente, el validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Date.html" class="api-link">Date</a></code> revisa que el valor
de entrada es una fecha con formato «YYYY-MM-DD».</p>
<p><span class="image-wrapper">
<a target="_blank" href="../../en/images/validators/validator_chain.png">
<img src="../../en/images/validators/validator_chain.png" alt="Figura 9.2. Cadena validadora" /></a>
<span class="image-caption">Figura 9.2. Cadena validadora</span>
</span>
</p>
<p>Para construir una cadena de validación como la de la figura 9.2, podemos usar
el siguiente código:</p>
<pre class=""><code class="language-php">&lt;?php
// Instantiate the validator chain.
$validator = new \Zend\Validator\ValidatorChain();

// Insert validators into validator chain.
$validator-&gt;attachByName('NotEmpty');
$validator-&gt;attachByName('StringLength', ['min'=&gt;1, 'max'=&gt;16]);
$validator-&gt;attachByName('Date', ['format'=&gt;'Y-m-d']);

// Execute all validators in the chain.
$isValid = $validator-&gt;isValid('2014-04-04'); // Returns true.
</code></pre>
<h3 id="Validador_personalizado_con_el_validador_Callback">9.6.4. Validador personalizado con el validador Callback</h3>
<p>El validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Callback.html" class="api-link">Callback</a></code> puede ser un envoltorio para nuestro algoritmo de validación
personalizado. Por ejemplo, puede ser útil cuando un validador no es apropiado
y necesitamos aplicar nuestro propio algoritmo de revisión a los datos. Los métodos
públicos provistos por el validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Callback.html" class="api-link">Callback</a></code> se listan en la tabla 9.14.</p>
<div class="table-wrapper">
<div class="table-caption">Tabla 9.14. Métodos públicos del validador Callback</div><table>
<thead>
<tr>
<th> <em>Nombre de la clase</em>           </th>
<th> <em>Descripción</em>                                                 </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>isValid($value, $context)</code>    </td>
<td>  Ejecuta una función de retro llamada como un validador.       </td>
</tr>
<tr>
<td> <code>getMessages()</code>                                                 </td>
<td> Si la validación falla, el método regresará un arreglo de       mensajes de error.                                            </td>
</tr>
<tr>
<td> <code>setCallback($callback)</code>       </td>
<td> Coloca una nueva retro llamada para el filtro.                </td>
</tr>
<tr>
<td> <code>getCallback()</code>                </td>
<td> Regresa la retro llamada asociada al filtro.                  </td>
</tr>
<tr>
<td> <code>setCallbackOptions($options)</code> </td>
<td> Coloca las opciones para la retro llamada.                    </td>
</tr>
<tr>
<td> <code>getCallbackOptions()</code>         </td>
<td> Recupera los parámetros de la retro llamada.                  </td>
</tr>
</tbody>
</table>
</div>
<p>Como se puede ver en la tabla, el validador <code>Callback</code> provee los métodos <code>setCallback()</code>
y <code>setCallbackOptions()</code> que se pueden usar para colocar las funciones de retro
llamada o métodos de una clase (opcionalmente) y pasarles uno o varios valores
parámetros.</p>
<h4 id="Ejemplo">9.6.4.1. Ejemplo</h4>
<p>Para demostrar el uso del validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Callback.html" class="api-link">Callback</a></code>, vamos a agregar un validador al
número de teléfono de nuestra clase de modelo de formulario <code>ContactForm</code>.
Este validador revisará el número de teléfono ingresado por el visitante del
sitio.</p>
<p>El validador debe ser capaz de revisar dos tipos de formato de número telefónico
comunes:</p>
<ul>
<li>El formato internacional que se ve: «1 (234) 567-8901»;</li>
<li>El formato local, que tiene el siguiente aspecto «567-8901».</li>
</ul>
<p>Como ZF3 no provee un validador estándar que filtre el número de teléfono, usaremos
el validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Callback.html" class="api-link">Callback</a></code> como envoltorio. Para conseguirlo, hacemos los siguientes
cambios al código de nuestra clase <code>ContactForm</code>:</p>
<pre class="line-numbers"><code class="language-php">&lt;?php
// ...
class ContactForm extends Form
{
  // ..
  protected function addElements() {
    // ...

    // Add "phone" field
    $this-&gt;add([
        'type'  =&gt; 'text',
        'name' =&gt; 'phone',
        'attributes' =&gt; [
          'id' =&gt; 'phone'
        ],
        'options' =&gt; [
          'label' =&gt; 'Your Phone',
        ],
      ]);
  }

  private function addInputFilter()
  {
    // ...

    $inputFilter-&gt;add([
            'name'     =&gt; 'phone',
            'required' =&gt; true,
            'validators' =&gt; [
                [
                  'name' =&gt; 'Callback',
                  'options' =&gt; [
                     'callback' =&gt; [$this, 'validatePhone'],
                     'callbackOptions' =&gt; [
                     'format' =&gt; 'intl'
                  ]
                ]
              ]
            ]
        );
  }

  // Custom validator for a phone number.
  public function validatePhone($value, $context, $format)
  {
    // Determine the correct length and pattern of the phone number,
    // depending on the format.
    if($format == 'intl') {
      $correctLength = 16;
      $pattern = '/^\d\ (\d{3}\) \d{3}-\d{4}$/';
    } else { // 'local'
      $correctLength = 8;
      $pattern = '/^\d{3}-\d{4}$/';
    }

    // Check phone number length.
    if(strlen($value)!=$correctLength)
      return false;

    // Check if the value matches the pattern.
    $matchCount = preg_match($pattern, $value);

    return ($matchCount!=0)?true:false;
  }
}
</code></pre>
<p>En el código de arriba, creamos el campo <code>phone</code> en nuestro <code>ContactForm</code>
(Si ya tenemos este campo, podemos ignorar este paso)</p>
<p>Entre las líneas 26-40, agregamos el validador <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Validator/Callback.html" class="api-link">Callback</a></code> a la cadena de validación
de filtros de entrada para el campo «phone».</p>
<p>En las líneas 44-64, tenemos el método de retro llamada <code>validatePhone()</code>. Este
método acepta tres argumentos: el parámetro <code>$value</code> es el número de teléfono
a validar, la variable <code>$context</code> recibe los valores de cada campo del formulario
(puede ser necesario para algunos validadores, revisar los valores de otro campos
del formulario) y el parámetro <code>$format</code> es el formato esperado para el número
de teléfono («intl» o «local»).</p>
<p>Dentro del método de retro llamada, hacemos lo siguiente:</p>
<ol>
<li>Calcular la longitud del número de teléfono, revisar si la longitud es correcta
para el formato de número de teléfono seleccionado.</li>
<li>Comparar el número de teléfono contra una expresión regular de acuerdo con
el formato de número de teléfono seleccionado.</li>
</ol>
        
</div>

<!-- Ads -->
<div id="ads-chapter-bottom">
<div>
﻿<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Using Zend Framework 3 Chapter - Bottom - Adaptive -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3933778336056438"
     data-ad-slot="1546211126"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
</div>
    
<!-- Navigation -->
<div class="navigation">
        <div class="current-chapter">
        <a href="../Revisar_los_datos_de_entrada_con_validadores.html">
            <img alt="Contents" src="../../assets/images/upload.png"><span class="nav-btn-text">Revisar los datos de entrada con validadores</span>
        </a>
    </div>
        <div class="prev-chapter">
        
        <a href="../Revisar_los_datos_de_entrada_con_validadores/El_administrador_de_complementos_para_validadores.html">
            <img alt="Previous Chapter" src="../../assets/images/left.png"><span class="nav-btn-text">Previous</span>
        </a>
        </div>    
    <div class="contents">
        <a href="../toc.html">
            <img alt="Contents" src="../../assets/images/book.png"><span class="nav-btn-text">Contents</span>
        </a>
    </div>
    <div class="next-chapter">
                <a href="../Revisar_los_datos_de_entrada_con_validadores/Escribir_nuestro_propio_validador.html">
            <span class="nav-btn-text">Next</span><img alt="Next Chapter" src="../../assets/images/right.png">
        </a>
            </div>        
</div>

<div id="disqus_thread"></div>

        
</div>
<footer>
    <div class="footer">
        <div class="footer-body">
            <div class="copyright">
                Copyright &copy; 2019 by Oleg Krivtsov            </div>
            <div class="footer-menu">
                                <div class="footer-link">
                    <a href="https://olegkrivtsov.github.io/using-zend-framework-3-book/legal/terms-and-conditions.html">Terms &amp; Conditions</a>
                </div>
                                <div class="footer-link">
                    <a href="https://olegkrivtsov.github.io/using-zend-framework-3-book/legal/copyright-policy.html">Copyright Policy</a>
                </div>
                                <div class="footer-link">
                    <a href="https://olegkrivtsov.github.io/using-zend-framework-3-book/legal/privacy-policy.html">Privacy Policy</a>
                </div>
                            </div>
            <div class="generated-by">
                Generated using <a href="https://github.com/olegkrivtsov/openbook">OpenBook</a>
            </div>
        </div>    
    </div>
</footer>

<a href="#0" class="cd-top">Top</a>

<script src="../../assets/js/jquery.min.js"></script>
<script src="../../assets/js/loadCSS.js"></script>
<script src="../../assets/js/popup.js"></script>

<script src="../../assets/js/prism.js"></script>

<script>
var disqus_config = function () {
this.page.url = window.location.href; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = ''; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//using-zend-framework-3-book.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script>
loadCSS("../../assets/css/prism.css");
</script>

<script>
jQuery(document).ready(function($){
    // browser window scroll (in pixels) after which the "back to top" link is shown
    var offset = 300,
    //browser window scroll (in pixels) after which the "back to top" link opacity is reduced
    offset_opacity = 1200,
    //duration of the top scrolling animation (in ms)
    scroll_top_duration = 700,
    //grab the "back to top" link
    $back_to_top = $('.cd-top');

    //hide or show the "back to top" link
    $(window).scroll(function(){
            ( $(this).scrollTop() > offset ) ? $back_to_top.addClass('cd-is-visible') : $back_to_top.removeClass('cd-is-visible cd-fade-out');
            if( $(this).scrollTop() > offset_opacity ) { 
                    $back_to_top.addClass('cd-fade-out');
            }
    });

    //smooth scroll to top
    $back_to_top.on('click', function(event){
            event.preventDefault();
            $('body,html').animate({
                    scrollTop: 0 ,
                    }, scroll_top_duration
            );
    });

});
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-80824388-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>    

