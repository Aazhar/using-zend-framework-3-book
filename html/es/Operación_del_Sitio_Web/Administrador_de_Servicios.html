<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="description" content="A free, read-frendly and open-source book on ZF3">
<meta name="keywords" content="zend framework,book,beginner,free">
<meta name="author" content="2018 by Oleg Krivtsov">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="../../favicon.ico" rel="shortcut icon" type="image/ico" />
<link href="../../assets/css/style.css" type="text/css" rel="stylesheet" />
<title>Administrador de Servicios &ndash; Using Zend Framework 3</title>
</head>
<body>
<header>
    <div class="header">
        <div class="header-body">
            <div class="book-title">
                <a href="../../index.html">Using Zend Framework 3</a>
            </div>
            <div class="book-subtitle">
                A free, read-frendly and open-source book on ZF3            </div>
            <nav>
                <div class="menu">
                                        <div class="link">
                        <a href="https://olegkrivtsov.github.io/using-zend-framework-3-book/html">Home</a>
                    </div>
                                        <div class="link">
                        <a href="https://github.com/olegkrivtsov/using-zf3-book-samples">Samples</a>
                    </div>
                                        <div class="link">
                        <a href="https://olegkrivtsov.github.io/zf3-api-reference/html/">Class Reference</a>
                    </div>
                                        <div class="link">
                        <a href="https://github.com/olegkrivtsov/using-zend-framework-3-book">Contribute</a>
                    </div>
                    
                </div>
            </nav>
        </div>    
    </div>
</header>    
<div id="container">
<!-- Navigation -->
<div class="navigation">
    <div class="prev-chapter">
        
        <a href="../Operación_del_Sitio_Web/Punto_de_Acceso_al_Módulo.html">
            <img alt="Previous Chapter" src="../../assets/images/left.png"><span class="nav-btn-text">Previous</span>
        </a>
        </div>    
    <div class="contents">
        <a href="../toc.html">
            <img alt="Contents" src="../../assets/images/book.png"><span class="nav-btn-text">Contents</span>
        </a>
    </div>
    <div class="next-chapter">
                <a href="../Operación_del_Sitio_Web/Administrador_de_Complementos.html">
            <span class="nav-btn-text">Next</span><img alt="Next Chapter" src="../../assets/images/right.png">
        </a>
            </div>
        <div class="current-chapter">
        <a href="../Operación_del_Sitio_Web.html">
            <img alt="Contents" src="../../assets/images/upload.png"><span class="nav-btn-text">Operación del Sitio Web</span>
        </a>
    </div>
    </div>

﻿<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Using Zend Framework 3 Book - Chapter - Adaptive -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3933778336056438"
     data-ad-slot="4531860323"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!-- Chapter content -->
<div id="chapter_content">
<div class="incomplete-translation">
    Translation into this language is not yet finished. You can help this project 
    by translating the chapters and contributing your changes.
</div>

<h2 id="Administrador_de_Servicios">3.10. Administrador de Servicios</h2>
<p>Podemos imaginar a la aplicación web como un conjunto de <em>servicios</em>. Por ejemplo,
podemos tener un servicio de autenticación responsable del inicio de sesión para
usuarios, un servicio administrador de entidades responsable del acceso
a la base de datos, un servicio para la administración de eventos responsable de
lanzar eventos y entregarlos al <em>listeners</em> de eventos, etc.</p>
<p>En Zend Framework la clase <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/ServiceManager/ServiceManager.html" class="api-link">ServiceManager</a></code> es un <em>contenedor</em> centralizado para
todos los servicios de aplicación. El administrador de servicios se implementa en
el componente <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/components/zendframework/zend-servicemanager.html" class="api-link">Zend\ServiceManager</a></code>, con la clase <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/ServiceManager/ServiceManager.html" class="api-link">ServiceManager</a></code>. El diagrama
de herencia de la clase se muestra en la figura 3.5:</p>
<p><span class="image-wrapper">
<a target="_blank" href="../../en/images/operation/service_manager_inheritance.png">
<img src="../../en/images/operation/service_manager_inheritance.png" alt="Figura 3.5. Diagrama de herencia de la clase administradora de servicios" /></a>
<span class="image-caption">Figura 3.5. Diagrama de herencia de la clase administradora de servicios</span>
</span>
</p>
<p>El administrador de servicios es creado luego de arrancar la aplicación (dentro
del método estático <code>init()</code> de la clase <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Mvc/Application.html" class="api-link">Zend\Mvc\Application</a></code>). Los servicios
estándares disponibles a través del administrador de servicios se presentan en la
tabla 3.1. Esta tabla está incompleta, porque el número actual de servicios registrados
en el administrador de servicios puede ser muy grande.</p>
<div class="table-wrapper">
<div class="table-caption">Tabla 3.1. Servicios Estándares</div><table>
<thead>
<tr>
<th> Nombre del Servicio  </th>
<th> Descripción                                                           </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>Application</code>        </td>
<td>  Permite recuperar la clase singleton <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Mvc/Application.html" class="api-link">Zend\Mvc\Application</a></code>.         </td>
</tr>
<tr>
<td> <code>ApplicationConfig</code>  </td>
<td> Arreglo de configuración extraído desde el archivo <em>application.config.php</em>. </td>
</tr>
<tr>
<td> <code>Config</code>                                    </td>
<td> Arreglo de configuración mezclado, extraído del archivo <em>module.config.php</em>   junto con <em>autoload/global.php</em> y el <em>autoload/local.php</em>.            </td>
</tr>
<tr>
<td> <code>EventManager</code>                                                     </td>
<td> Permite recuperar una <em>nueva</em> instancia de la clase                     <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/EventManager/EventManager.html" class="api-link">Zend\EventManager\EventManager</a></code>. El administrador de eventos permite  enviar (lanzar) eventos y asociar <em>listeners</em> de evento.              </td>
</tr>
<tr>
<td> <code>SharedEventManager</code>                                               </td>
<td> Permite recuperar una instancia <em>singleton</em> de la clase <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/EventManager/SharedEventManager.html" class="api-link">Zend\EventManager\SharedEventManager</a></code>.   El administrador de eventos compartidos permite escuchar eventos definidos   por otras clases y componentes.                                       </td>
</tr>
<tr>
<td> <code>ModuleManager</code>                             </td>
<td> Permite recuperar una clase <em>singleton</em> de <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/ModuleManager/ModuleManager.html" class="api-link">Zend\ModuleManager\ModuleManager</a></code>.   El administrador de módulos es responsable de cargar los módulos de la aplicación. </td>
</tr>
<tr>
<td> <code>Request</code>                                   </td>
<td> La clase <em>singleton</em> de <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Http/Request.html" class="api-link">Zend\Http\Request</a></code>. Representa una petición HTTP   recibida desde el client.                                             </td>
</tr>
<tr>
<td> <code>Response</code>                                  </td>
<td> La clase <em>singleton</em> de <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Http/Response.html" class="api-link">Zend\Http\Response</a></code>. Representa la respuesta HTTP   que será enviada al cliente.                                          </td>
</tr>
<tr>
<td> <code>Router</code>                                    </td>
<td> La clase <em>singleton</em> de <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Router/Http/TreeRouteStack.html" class="api-link">Zend\Router\Http\TreeRouteStack</a></code>. Ejecuta el  direccionamiento URL.                                                 </td>
</tr>
<tr>
<td> <code>ServiceManager</code>     </td>
<td> El administrador de servicios.                                        </td>
</tr>
<tr>
<td> <code>ViewManager</code>                               </td>
<td> La clase <em>singleton</em> de <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Mvc/View/Http/ViewManager.html" class="api-link">Zend\Mvc\View\Http\ViewManager</a></code>. Responsable  de preparar la capa de vista para pintar la página.                   </td>
</tr>
</tbody>
</table>
</div>
<p>Un servicio es típicamente una clase PHP arbitraria, pero no siempre. Por ejemplo,
cuando ZF3 carga los archivos de configuración y mezcla los datos dentro de un arreglo
anidado, se guarda el arreglo en dos servicios del administrador de servicios: <code>ApplicationConfig</code> y
<code>Config</code>. El primero es una arreglo cargado desde el nivel de aplicación con el
archivo <em>application.config.php</em> y el segundo servicio es la mezcla de los archivos de configuración
a nivel de módulo y los archivos de configuración autocargados del nivel de aplicación.
Luego, en el administrador de eventos podemos guardar cualquier cosa que queramos:
una clase PHP, una simple variable o un arreglo.</p>
<p>En la tabla 3.1 podemos ver que en ZF3 casi todo se puede considerar un servicio.
El administrador de servicios mismo se registra como un servicio. Además, la clase
<code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Mvc/Application.html" class="api-link">Application</a></code> se registra también como un servicio.</p>
<blockquote class="notquote information" data-type="information"><p> Una cosa importante que deberías saber sobre los servicios es que ellos se guardan
 <em>normalmente</em> en una única instancia (este es un patrón llamado <em>singleton</em>).
 Obviamente, no necesitamos otra instancia de la clase <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Mvc/Application.html" class="api-link">Application</a></code> (o podríamos
 tener una pesadilla).</p>
</blockquote><blockquote class="notquote tip" data-type="tip"><p> Pero existe una importante excepción para la regla de arriba. Aunque puede ser confuso
 al principio el <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/EventManager/EventManager.html" class="api-link">EventManager</a></code> no es un singleton. Cada vez que recuperamos el
 administrador de eventos desde el administrador de servicios recibimos un <em>nuevo</em>
 objeto. Esto se hace por razones de rendimiento y para evitar conflictos entre
 eventos de distintos componentes. Discutiremos esto luego en la sección
 <em>Sobre los Administradores de Eventos</em> de este capítulo.</p>
</blockquote><p>El administrador de servicios define varios métodos necesarios para localizar y
recuperar un servicio desde el administrador de servicios (ver la tabla 3.2).</p>
<div class="table-wrapper">
<div class="table-caption">Tabla 3.2. Métodos del ServiceManager</div><table>
<thead>
<tr>
<th> Nombre del Método    </th>
<th> Descripción                                                           </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>has($name)</code>         </td>
<td>  Revisa si el servicio está registrado.                                </td>
</tr>
<tr>
<td> <code>get($name)</code>         </td>
<td> Recupera una instancia del servicio registrado.                       </td>
</tr>
<tr>
<td> <code>build($name, $options)</code> </td>
<td> Siempre regresa una nueva instancia del servicio solicitado.      </td>
</tr>
</tbody>
</table>
</div>
<p>Podemos probar si un servicio está registrado pasando su nombre al método <code>has()</code>
del administrador de servicios. Si regresa el valor booleano <code>true</code> el servicio
está registrado, si regresa <code>false</code> el servicio con el nombre dado no está registrado.</p>
<p>Luego podemos recuperar un servicio a partir de su nombre con la ayuda del método
<code>get()</code> del administrador de servicios. Este método toma un único parámetro que
representa el nombre del servicio. Veamos el siguiente ejemplo:</p>
<pre class=""><code class="language-php">&lt;?php

// Retrieve the application config array.
$appConfig = $serviceManager-&gt;get('ApplicationConfig');

// Use it (for example, retrieve the module list).
$modules = $appConfig['modules'];
</code></pre>
<p>Cuando se llama al método <code>build()</code> siempre se crea una nueva instancia del servicio (comparado
con <code>get()</code> que normalmente crea una instancia del servicio una sola vez y la regresa
luego en cada nueva petición).</p>
<blockquote class="notquote tip" data-type="tip"><p> Normalmente no recuperamos servicios con el administrador de servicios desde
 cualquier lugar de nuestro código sino dentro de una <em>fábrica</em>. Una fábrica
 es un código responsable de crear un objeto. Cuando se crea el objeto podemos
 traer desde administrador de servicios a los servicios de que depende el objeto
 que estamos creando y pasar estos
 servicios (dependencias) al constructor del objeto. A esto se le llama
 <em>inyección de dependencias</em>.</p>
</blockquote><blockquote class="notquote information" data-type="information"><p> Si tenemos alguna experiencia con Zend Framework 2 podemos ver que las cosas ahora
 son un poco diferentes. En ZF2, había un patrón <code>ServiceLocator</code> que
 permitía traer dependencias desde administrador de servicios en <em>cualquier</em>
 parte de la aplicación (controladores, servicios, etc). En ZF3, tenemos que pasar
 las dependencias explícitamente. Esto es un poco aburrido pero remueve las dependencias
 «ocultas» y hace que nuestro código sea más fácil y claro de entender.</p>
</blockquote><h3 id="Registrar_un_Servicio">3.10.1. Registrar un Servicio</h3>
<p>Cuando escribimos un sitio web a menudo necesitamos registrar nuestro propio servicio
en el administrador de servicios. Una de las maneras de registrar un servicio es
usando el método <code>setService()</code> del administrador de servicios. Por ejemplo, vamos
a crear y registrar la clase de servicio que convierte monedas y que se usa, por ejemplo,
en una página con carrito de compras para convertir EUR a USD:</p>
<pre class="line-numbers"><code class="language-php">&lt;?php
// Define a namespace where our custom service lives.
namespace Application\Service;

// Define a currency converter service class.
class CurrencyConverter
{
    // Converts euros to US dollars.
    public function convertEURtoUSD($amount)
    {
        return $amount*1.25;
    }

    //...
}
</code></pre>
<p>Arriba entre las líneas 6 y 15 definimos una clase <code>CurrencyConverter</code> de ejemplo
(por simplicidad, implementamos solo un método <code>convertEURtoUSD()</code> que es capaz
de convertir euros a dolares norte americanos).</p>
<pre class=""><code class="language-php">// Create an instance of the class.
$service = new CurrencyConverter();
// Save the instance to service manager.
$serviceManager-&gt;setService(CurrencyConverter::class, $service);
</code></pre>
<p>En este ejemplo se crea una instancia de la clase con el operador <code>new</code> y la registramos en el
administrador de servicios usando el método <code>setService()</code> (asumimos que la variable 
<code>$serviceManager</code> es de tipo <em>class</em> correspondiente a <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/ServiceManager/ServiceManager.html" class="api-link">Zend\ServiceManager\ServiceManager</a></code>
y que ha sido declarada en algún lugar).</p>
<p>El método <code>setService()</code> toma dos parámetros: una cadena de caracteres que es el
nombre del servicio y la instancia del servicio. El nombre del servicio debe ser
único entre todos los otros servicios posibles.</p>
<p>Una vez que el servicio se almacena en el administrador de servicios podemos recuperarlo
por su nombre en cualquier lugar de la aplicación con la ayuda del método <code>get()</code>
del administrador de servicios. Miremos el siguiente ejemplo:</p>
<pre class=""><code class="language-php">&lt;?php
// Retrieve the currency converter service.
$service = $serviceManager-&gt;get(CurrencyConverter::class);

// Use it (convert money amount).
$convertedAmount = $service-&gt;convertEURtoUSD(50);
</code></pre>
<h3 id="Nombres_de_Servicio">3.10.2. Nombres de Servicio</h3>
<p>Diferentes servicios pueden usar diferentes convenciones de nomenclatura. Por ejemplo,
el mismo servicio que convierte monedas puede ser registrado con diferentes nombres:
<code>CurrencyConverter</code>, <code>currency_converter</code>, etc. Podemos introducir una convención
para hacer uniforme los nombres, recomendamos registrar un servicio por su nombre
de clase completo, <em>fully qualified name</em>, de la siguiente manera:</p>
<pre class=""><code class="language-php">$serviceManager-&gt;setService(CurrencyConverter::class);
</code></pre>
<p>En el ejemplo de arriba usamos la palabra clave <code>class</code>. Esta se encuentra disponible desde
PHP 5.5 y se usa para la resolución de nombres de clase. <code>CurrencyConverter::class</code>
se expande al nombre completo de la clase, es decir <code>\Application\Service\CurrencyConverter</code>.</p>
<h3 id="Sobrescribir_un_Servicio_Existente">3.10.3. Sobrescribir un Servicio Existente</h3>
<p>Si estamos intentando registrar un nombre de servicio que ya está registrado el
método <code>setService()</code> lanzará una excepción. Sin embargo, en ocasiones queremos sobrescribir
el servicio con el mismo nombre (reemplazarlo por uno nuevo). Con este propósito,
podemos usar el método del administrador de servicios <code>setAllowOverride()</code>.</p>
<pre class=""><code class="language-php">&lt;?php
// Allow to replace services
$serviceManager-&gt;setAllowOverride(true);

// Save the instance to service manager. There will be no exception
// even if there is another service with such a name.
$serviceManager-&gt;setService(CurrencyConverter::class, $service);
</code></pre>
<p>El método <code>setAllowOverride()</code> toma un único parámetro booleano que define si se permite
reemplazar el servicio <code>CurrencyConverter</code> tanto si ya está registrado como si no.</p>
<h3 id="Registrar_Clases_Invocables">3.10.4. Registrar Clases Invocables</h3>
<p>Hay algo que está mal con el método <code>setService()</code>, si se usa tenemos que crear la instancia
del servicio antes de que realmente lo necesitemos. Si nunca usamos el servicio la
instanciación del servicio solo derrochará tiempo y memoria. Para resolver esta
cuestión el administrador de servicios nos provee del método <code>setInvokableClass()</code>.</p>
<pre class=""><code class="language-php">&lt;?php
// Register an invokable class
$serviceManager-&gt;setInvokableClass(CurrencyConverter::class);
</code></pre>
<p>En el ejemplo de arriba pasamos al administrador de servicios el nombre completo
de la clase (fully qualified) que implementa el servicio en lugar de pasar su 
instancia. Con esta técnica, el
servicio será instanciado por el administrador de servicios solo cuando se
llama al método <code>get(CurrencyConverter::class)</code>. A esta técnica también se le 
llama <em>lazy loading</em>.</p>
<blockquote class="notquote tip" data-type="tip"><p> Los servicios a menudo dependen de otro. Por ejemplo, el servicio que convierte
 monedas puede usar el servicio de administración de entidades para leer la tasa de cambio
 desde la base de datos. La desventaja del método <code>setInvokableClass()</code> es que
 no permite pasar parámetros (dependencias) al servicio en la instanciación del
 objeto. Para resolver esta cuestión podemos usar <em>fábricas</em> (factories) como 
 se describe más adelante.</p>
</blockquote><h3 id="Registrar_una_Fábrica">3.10.5. Registrar una Fábrica</h3>
<p>Una fábrica es una clase que solo puede hacer una cosa, crear otros objetos.</p>
<p>Registramos una fábrica para un servicio con el método <code>setFactory()</code> del administrador
de servicios.</p>
<p>La fábrica más simple es <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/ServiceManager/Factory/InvokableFactory.html" class="api-link">InvokableFactory</a></code>, esta es análoga al método <code>setInvokableClass()</code>
de la sección anterior.</p>
<pre class=""><code class="language-php">&lt;?php
use Zend\ServiceManager\Factory\InvokableFactory;

// This is equivalent to the setInvokableClass() method from previous section.
$serviceManager-&gt;setFactory(CurrencyConverter::class, InvokableFactory::class);
</code></pre>
<p>Después de haber registrado la fábrica podemos recuperar el servicio desde el administrador
de servicios como es usual usando el método <code>get()</code>. El servicio se instanciará
solo cuando lo recuperemos desde el administrador de servicios (lazy loading).</p>
<p>En ocasiones la instanciación de un servicio es más compleja que solo crear la instancia
del servicio con el operador <code>new</code> (como lo hace la clase <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/ServiceManager/Factory/InvokableFactory.html" class="api-link">InvokableFactory</a></code>). Podemos
necesitar pasar algunos parámetros al constructor del servicio o invocar algunos
métodos del servicio justo después de la construcción. Esta lógica de instanciación
compleja se puede encapsular dentro de nuestra propia clase <em>fábrica</em> escrita a la
medida. La clase fábrica normalmente implementa a la interfaz 
<code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/ServiceManager/Factory/FactoryInterface.html" class="api-link">FactoryInterface</a></code>:</p>
<pre class=""><code class="language-php">&lt;?php
namespace Zend\ServiceManager\Factory;

use Interop\Container\ContainerInterface;

interface FactoryInterface
{
    public function __invoke(ContainerInterface $container,
                        $requestedName, array $options = null);
}
</code></pre>
<p>Como podemos ver a partir de la definición de la interfaz 
<code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/ServiceManager/Factory/FactoryInterface.html" class="api-link">FactoryInterface</a></code>,
la clase fábrica debe
proveer el método mágico <code>__invoke</code> que retorna una instancia de un solo servicio.
El administrador de servicios se pasa al método <code>__invoke</code> en el parámetro <code>$container</code>;
este se puede usar durante la construcción del servicio para acceder a otros servicios
(inyectar <em>dependencias</em>). El segundo parámetro (<code>$requestedName</code>) es el nombre del
servicio. El tercer argumento (<code>$options</code>) se puede usar para pasar algunos parámetros
al servicio y se usa solo cuando pedimos el servicio con el método del administrador
de servicios <code>build()</code>.</p>
<p>Como un ejemplo, vamos a escribir una fábrica para nuestro servicio que convierte
monedas (ver el código de abajo). No usamos una lógica de construcción compleja para
nuestro servicio <code>CurrencyConverter</code> pero para servicios más complejos necesitaremos
hacerlo.</p>
<pre class=""><code class="language-php">&lt;?php
namespace Application\Service\Factory;

use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\CurrencyConverter;

// Factory class
class CurrencyConverterFactory implements FactoryInterface
{
    public function __invoke(ContainerInterface $container,
                     $requestedName, array $options = null)
    {
        // Create an instance of the class.
        $service = new CurrencyConverter();

        return $service;
    }
}
</code></pre>
<blockquote class="notquote information" data-type="information"><p> Técnicamente, con ZF3 <em>podemos</em> usar la misma clase fábrica para instanciar varios
 servicios que tienen código de instanciación similar (para este propósito podemos
 usar el argumento <code>$requestedName</code> que se pasa al método fábrica <code>__invoke()</code>).
  Sin embargo, <em>principalmente</em> crearemos diferentes fábrica una por cada servicio.</p>
</blockquote><h3 id="Registrar_un_Fábrica_Abstracta">3.10.6. Registrar un Fábrica Abstracta</h3>
<p>Un escenario más complejo para una fábrica es cuando necesitamos determinar en tiempo de ejecución
cuales nombres de servicios deberían ser registrados. En esta situación podemos
usar una <em>fábrica abstracta</em>. Una fábrica abstracta deberá implementar la interfaz
<code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/ServiceManager/Factory/AbstractFactoryInterface.html" class="api-link">AbstractFactoryInterface</a></code>:</p>
<pre class=""><code class="language-php">&lt;?php
namespace Zend\ServiceManager\Factory;

use Interop\Container\ContainerInterface;

interface AbstractFactoryInterface extends FactoryInterface
{
    public function canCreate(ContainerInterface $container, $requestedName);
}
</code></pre>
<p>Una fábrica abstracta tiene dos métodos: <code>canCreate()</code> e <code>__invoke()</code>. La primera
es necesaria para revisar si la fábrica puede crear el servicio con determinado nombre y
el segundo permite crear el servicio. Los métodos toman dos parámetros: el administrador
de servicios (<code>$container</code>) y el nombre del servicio (<code>$requestedName</code>).</p>
<p>En comparación con la clase fábrica normal, la diferencia está en que la clase fábrica
normal <em>generalmente</em> crea solo un tipo de servicio pero la clase abstracta puede
crear dinámicamente tantos tipos de servicios como se quiera.</p>
<p>Registramos una fábrica abstracta con el método del administrador de servicios
<code>setAbstractFactory()</code>.</p>
<blockquote class="notquote tip" data-type="tip"><p> Las fábricas abstractas son una poderosa característica pero solo deberíamos usarlas
 cuando realmente es necesario, porque ellas impactan negativamente en el rendimiento.
 Es mejor usar las fábricas usuales (no abstractas).</p>
</blockquote><h3 id="Registrar_Alias_de_Servicios">3.10.7. Registrar Alias de Servicios</h3>
<p>A veces podemos querer definir un <em>alias</em> para el servicio. Los alias son como enlaces
simbólicos: estos hacen referencia a servicios que ya están registrados. Para crear
un alias usamos el método <code>setAlias()</code> del administrador de servicios:</p>
<pre class=""><code class="language-php">&lt;?php
// Register an alias for the CurrencyConverter service
$serviceManager-&gt;setAlias('CurConv', CurrencyConverter::class);
</code></pre>
<p>Una vez registrado podemos recuperar el servicio usando el método <code>get()</code> del administrador
de servicios tanto con el nombre como con el alias.</p>
<h3 id="Servicios_Compartidos_y_no_Compartidos">3.10.8. Servicios Compartidos y no Compartidos</h3>
<p>Por defecto los servicios se guardan en una sola instancia en el administrador de
servicios. A esto también se le llama patrón de diseño <em>singleton</em>. Por ejemplo,
cuando intentamos recuperar dos veces el servicio <code>CurrencyConverter</code> recibiremos
el mismo objeto. A esto lo llamamos un servicio <em>compartido</em>.</p>
<p>Pero en algunas (raras) ocasiones necesitamos crear una <em>nueva</em> instancia de un
servicio cada vez que alguien lo pida al administrador de servicios. Un ejemplo de
esto es el <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/EventManager/EventManager.html" class="api-link">EventManager</a></code>, tendremos una nueva instancia de él cada vez que lo pidamos.</p>
<p>Para marcar un servicio como no compartido podemos usar el método del administrador
de servicios <code>setShared()</code>:</p>
<pre class=""><code class="language-php">$serviceManager-&gt;setShared('EventManager', false);
</code></pre>
<h3 id="Configuración_del_Administrador_de_Servicios">3.10.9. Configuración del Administrador de Servicios</h3>
<p>En nuestro sitio web normalmente usamos la configuración del administrador de servicios
para registrar nuestros servicios (en lugar de llamar a los métodos del administrador
de servicios como describimos arriba).</p>
<p>Para registrar automáticamente un servicio dentro del administrador de servicios,
normalmente usamos la llave <code>service_manager</code> en el archivo de configuración. Podemos
colocar esta llave dentro de un archivo de configuración a nivel de aplicación
o en un archivo de configuración a nivel de módulo.</p>
<blockquote class="notquote warning" data-type="warning"><p> Si colocamos esta llave en el archivo de configuración a nivel de módulo debemos
 ser cuidadosos de no sobrescribir el nombre durante la mezcla de la configuración.
 No debemos registrar el mismo nombre de servicio en diferentes módulos.</p>
</blockquote><p>La llave <code>service_manager</code> debería verse así:</p>
<pre class="line-numbers"><code class="language-php">&lt;?php
return [
    //...

    // Register the services under this key
    'service_manager' =&gt; [
        'services' =&gt; [
            // Register service class instances here
            //...
        ],
        'invokables' =&gt; [
            // Register invokable classes here
            //...
        ],
        'factories' =&gt; [
            // Register factories here
            //...
        ],
        'abstract_factories' =&gt; [
            // Register abstract factories here
            //...
        ],
        'aliases' =&gt; [
            // Register service aliases here
            //...
        ],
        'shared' =&gt; [
            // Specify here which services must be non-shared
        ]
  ],

  //...
];
</code></pre>
<p>En el ejemplo de arriba podemos ver que la llave <code>service_manager</code> puede contener
varias subllaves para registrar servicios de diferentes maneras:</p>
<ul>
<li>la subllave <code>services</code> (línea 7) permite registrar instancias de clases.</li>
<li>la subllave <code>invokables</code> (línea 11) permite registrar un nombre completo de clase;
el servicio será instanciado usando <em>lazy loading</em>.</li>
<li>la subllave <code>factories</code> (línea 15) permite registrar una fábrica, que es capaz
de crear instancias de un solo servicio.</li>
<li>la subllave <code>abstract_factories</code> (línea 9) se usa para registrar fábricas abstractas,
que son capaces de registrar varios servicios por nombre.</li>
<li>la subllave <code>aliases</code> (línea 23) provee la capacidad de registrar un alias para un
servicio.</li>
<li>la subllave <code>shared</code> (línea 27) permite especificar cuales servicios no deben ser
compartidos.</li>
</ul>
<p>A manera de ejemplo vamos a registrar nuestro servicio <code>CurrencyConverter</code> y crearemos
un alias para él:</p>
<pre class=""><code class="language-php">&lt;?php
use Zend\ServiceManager\Factory\InvokableFactory;
use Application\Service\CurrencyConverter;

return [
    //...

    // Register the services under this key
    'service_manager' =&gt; [
        'factories' =&gt; [
            // Register CurrencyConverter service.
            CurrencyConverter::class =&gt; InvokableFactory::class
        ],
        'aliases' =&gt; [
            // Register an alias for the CurrencyConverter service.
            'CurConv' =&gt; CurrencyConverter::class
        ],
  ],

  //...
];
</code></pre>
        
</div>

<!-- Ads -->
<div id="ads-chapter-bottom">
<div>
﻿<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Using Zend Framework 3 Chapter - Bottom - Adaptive -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3933778336056438"
     data-ad-slot="1546211126"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
</div>
    
<!-- Navigation -->
<div class="navigation">
        <div class="current-chapter">
        <a href="../Operación_del_Sitio_Web.html">
            <img alt="Contents" src="../../assets/images/upload.png"><span class="nav-btn-text">Operación del Sitio Web</span>
        </a>
    </div>
        <div class="prev-chapter">
        
        <a href="../Operación_del_Sitio_Web/Punto_de_Acceso_al_Módulo.html">
            <img alt="Previous Chapter" src="../../assets/images/left.png"><span class="nav-btn-text">Previous</span>
        </a>
        </div>    
    <div class="contents">
        <a href="../toc.html">
            <img alt="Contents" src="../../assets/images/book.png"><span class="nav-btn-text">Contents</span>
        </a>
    </div>
    <div class="next-chapter">
                <a href="../Operación_del_Sitio_Web/Administrador_de_Complementos.html">
            <span class="nav-btn-text">Next</span><img alt="Next Chapter" src="../../assets/images/right.png">
        </a>
            </div>        
</div>

<div id="disqus_thread"></div>

        
</div>
<footer>
    <div class="footer">
        <div class="footer-body">
            <div class="copyright">
                Copyright &copy; 2018 by Oleg Krivtsov            </div>
            <div class="footer-menu">
                                <div class="footer-link">
                    <a href="https://olegkrivtsov.github.io/using-zend-framework-3-book/legal/terms-and-conditions.html">Terms &amp; Conditions</a>
                </div>
                                <div class="footer-link">
                    <a href="https://olegkrivtsov.github.io/using-zend-framework-3-book/legal/copyright-policy.html">Copyright Policy</a>
                </div>
                                <div class="footer-link">
                    <a href="https://olegkrivtsov.github.io/using-zend-framework-3-book/legal/privacy-policy.html">Privacy Policy</a>
                </div>
                            </div>
            <div class="generated-by">
                Generated using <a href="https://github.com/olegkrivtsov/openbook">OpenBook</a>
            </div>
        </div>    
    </div>
</footer>

<a href="#0" class="cd-top">Top</a>

<script src="../../assets/js/jquery.min.js"></script>
<script src="../../assets/js/loadCSS.js"></script>
<script src="../../assets/js/popup.js"></script>

<script src="../../assets/js/prism.js"></script>

<script>
var disqus_config = function () {
this.page.url = window.location.href; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = ''; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//using-zend-framework-3-book.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script>
loadCSS("../../assets/css/prism.css");
</script>

<script>
jQuery(document).ready(function($){
    // browser window scroll (in pixels) after which the "back to top" link is shown
    var offset = 300,
    //browser window scroll (in pixels) after which the "back to top" link opacity is reduced
    offset_opacity = 1200,
    //duration of the top scrolling animation (in ms)
    scroll_top_duration = 700,
    //grab the "back to top" link
    $back_to_top = $('.cd-top');

    //hide or show the "back to top" link
    $(window).scroll(function(){
            ( $(this).scrollTop() > offset ) ? $back_to_top.addClass('cd-is-visible') : $back_to_top.removeClass('cd-is-visible cd-fade-out');
            if( $(this).scrollTop() > offset_opacity ) { 
                    $back_to_top.addClass('cd-fade-out');
            }
    });

    //smooth scroll to top
    $back_to_top.on('click', function(event){
            event.preventDefault();
            $('body,html').animate({
                    scrollTop: 0 ,
                    }, scroll_top_duration
            );
    });

});
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-80824388-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>    

