<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="description" content="A free and open-source book on ZF3 for beginners">
<meta name="keywords" content="zend framework,book,beginner,free">
<meta name="author" content="2019 by Oleg Krivtsov">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="../../favicon.ico" rel="shortcut icon" type="image/ico" />
<link href="../../assets/css/style.css" type="text/css" rel="stylesheet" />
<title>Chargement automatique des classes PHP &ndash; Using Zend Framework 3</title>
</head>
<body>
<header>
    <div class="header">
        <div class="header-body">
            <div class="book-title">
                <a href="../../index.html">Using Zend Framework 3</a>
            </div>
            <div class="book-subtitle">
                A free and open-source book on ZF3 for beginners            </div>
            <nav>
                <div class="menu">
                                        <div class="link">
                        <a href="https://olegkrivtsov.github.io/using-zend-framework-3-book/html">Home</a>
                    </div>
                                        <div class="link">
                        <a href="https://github.com/olegkrivtsov/using-zf3-book-samples">Samples</a>
                    </div>
                                        <div class="link">
                        <a href="https://olegkrivtsov.github.io/zf3-api-reference/html/">Class Reference</a>
                    </div>
                                        <div class="link">
                        <a href="https://github.com/olegkrivtsov/using-zend-framework-3-book">Contribute</a>
                    </div>
                    
                </div>
            </nav>
        </div>    
    </div>
</header>    
<div id="container">
<!-- Navigation -->
<div class="navigation">
    <div class="prev-chapter">
        
        <a href="../Fonctionnement_d_un_site/Les_Interfaces_PHP.html">
            <img alt="Previous Chapter" src="../../assets/images/left.png"><span class="nav-btn-text">Previous</span>
        </a>
        </div>    
    <div class="contents">
        <a href="../toc.html">
            <img alt="Contents" src="../../assets/images/book.png"><span class="nav-btn-text">Contents</span>
        </a>
    </div>
    <div class="next-chapter">
                <a href="../Fonctionnement_d_un_site/Requête_et_Réponse_HTTP.html">
            <span class="nav-btn-text">Next</span><img alt="Next Chapter" src="../../assets/images/right.png">
        </a>
            </div>
        <div class="current-chapter">
        <a href="../Fonctionnement_d_un_site.html">
            <img alt="Contents" src="../../assets/images/upload.png"><span class="nav-btn-text">Fonctionnement d'un site</span>
        </a>
    </div>
    </div>

﻿<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Using Zend Framework 3 Book - Chapter - Adaptive -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3933778336056438"
     data-ad-slot="4531860323"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!-- Chapter content -->
<div id="chapter_content">
<div class="incomplete-translation">
    Translation into this language is not yet finished. You can help this project 
    by translating the chapters and contributing your changes.
</div>

<h2 id="Chargement_automatique_des_classes_PHP">3.4. Chargement automatique des classes PHP</h2>
<p>Une application se compose de nombreuses classes PHP et chaque classe réside généralement dans un
fichier distinct. Cela introduit le besoin d'<em>inclure</em> les fichiers.</p>
<p>Par exemple, supposons que nous ayons le fichier <em>Application.php</em> qui contient la définition de la classe
<code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Mvc/Application.html" class="api-link">\Zend\Mvc\Application</a></code> de la section précédente. Avant de pouvoir créer une instance de la classe
<code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Mvc/Application.html" class="api-link">Application</a></code> quelque part dans votre code, vous devez inclure le contenu du fichier <em>Application.php</em>
(vous pouvez le faire à l'aide de l'instruction <code>require_once</code> en lui passant le chemin d'accès complet
au fichier) :</p>
<pre class=""><code class="language-php">&lt;?php
require_once "/path/to/zendframework/zend-mvc/src/Application.php";

use Zend\Mvc\Application;

$application = new Application();
</code></pre>
<p>Au fur et à mesure que votre application augmente en taille, il peut être difficile d'inclure chaque
fichier nécessaire. Zend Framework 3 lui-même se compose de centaines de fichiers, et il peut être très
difficile de charger la bibliothèque entière et toutes ses dépendances de cette façon. De plus, lors de
l'exécution du code résultant, l'interpréteur PHP prendra du temps CPU pour traiter chaque fichier inclus,
même si vous ne créez pas une instance de ladite classe.</p>
<p>Pour résoudre ce problème, en PHP, une fonctionnalité de chargement automatique de classe a été introduite.
La fonction PHP <code>spl_autoload_register()</code> vous permet de créer une fonction d'<em>autoloading</em> (chargement automatique).
Pour les sites complexes, vous pouvez même créer plusieurs fonctions de chargement automatique, qui sont
chaînées dans une pile.</p>
<p>Pendant l'exécution du script, si l'interpréteur PHP rencontre un nom de classe qui n'a pas encore été défini,
il appelle la ou les autoloaders déclarées jusqu'à ce qu'il y en est un qui
trouve la classe ou que l'erreur "not found" soit levée. Cela permet un chargement "lazy" (paresseux),
l'interpréteur PHP ne traite la définition de la classe qu'au moment de l'appel de cette classe,
ie, quand cela est vraiment nécessaire.</p>
<h3 id="Mapping_d_une_classe_Autoloader">3.4.1. Mapping d'une classe Autoloader</h3>
<p>Pour vous donner une idée de la façon dont une fonction d'autoloading se présente, voyons ci-dessous une
implémentation simplifiée d'une fonction d'autoloading :</p>
<pre class=""><code class="language-php">&lt;?php
// Autoloader function.
function autoloadFunc($className)
{
    // Mappage des classes dans un tableau statique.
    static $classMap = [
        '\\Zend\\Mvc\\Application' =&gt; '/path/to/zendframework/zend-mvc/src/Zend/Mvc/Application.php',
        '\\Application\\Module' =&gt; '/path/to/app/dir/module/Application/Module.php',
        //...
    ];

    // Vérifie si un tel nom de classe est présent dans la class map.
    if(isset(static::$classMap[$className])) {
        $fileName = static::$classMap[$className];

        // Vérifie si le fichier existe et est lisible.
        if (is_readable($fileName)) {
            // Inclus le fichier.
            require $fileName;
        }
    }
}

// Déclaration de la function d'autoloading
spl_autoload_register("autoloadFunc");
</code></pre>
<p>Dans l'exemple ci-dessus, nous définissons la fonction de chargement automatique <code>autoloadFunc()</code>
que nous désignerons sous le nom de <em>class map</em> d'autoloader.</p>
<p>L'autoloader de class map utilise le mappage de classe pour mapper le nom de classe et le chemin absolu
vers le fichier PHP contenant cette classe. La class map est juste un tableau PHP contenant des clés et
des valeurs. Pour déterminer le chemin d'accès au fichier par nom de classe, l'autoloader de la classe
doit simplement extraire la valeur du tableau de class map. Il est évident que l'autoloader de class map
fonctionne très vite. Cependant, le désavantage est que vous devez maintenir la class map et la mettre à
jour à chaque fois que vous ajoutez une nouvelle classe à votre programme.</p>
<h3 id="La_Norme_PSR_4">3.4.2. La Norme PSR-4</h3>
<p>Comme chaque fournisseur de bibliothèque utilise ses propres conventions de nommage et d'organisation de
fichier, vous devrez enregistrer une fonction de chargement automatique personnalisée différente pour
chaque bibliothèque dépendante, ce qui est plutôt ennuyeux.
Pour résoudre ce problème, la norme PSR-4 a été introduite.</p>
<blockquote class="notquote information" data-type="information"><p> PSR signifie PHP Standards Recommendation.</p>
</blockquote><p>La <a target="_blank" href="http://www.php-fig.org/psr/psr-4/">norme PSR-4</a>
définit la structure de code recommandée qu'une application ou une bibliothèque doit suivre pour garantir
l'interopérabilité de l'autoloader. En deux mots, la norme dit que :</p>
<ul>
<li><p>Les espaces de noms doivent être organisés de la manière suivante :</p>
<p><code>\&lt;Vendor Name&gt;\(&lt;Namespace&gt;)*\&lt;Class Name&gt;</code></p>
</li>
<li><p>Les espaces de noms peuvent avoir autant de niveaux d'imbrication que vous le souhaitez, mais le nom du
fournisseur (vendor) doit correspondre au niveau supérieur.</p>
</li>
<li><p>Les espaces de noms doivent correspondre à la structure du répertoire. Chaque séparateur d'espace de
noms ('\') est converti en une constante <code>DIRECTORY_SEPARATOR</code> spécifique au système d'exploitation
lors du chargement à partir du système de fichiers.</p>
</li>
<li><p>Le nom de la classe est suffixé avec l'extension <em>.php</em> lors du chargement du fichier à partir du système de fichiers.</p>
</li>
</ul>
<p>Par exemple, pour la classe <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Mvc/Application.html" class="api-link">Zend\Mvc\Application</a></code>,
vous aurez la structure de répertoire suivante :</p>
<pre class=""><code class="language-text">/path/to/zendframework/zend-mvc/src
  /Zend
    /Mvc
       Application.php
</code></pre>
<p>L'inconvénient de ceci est que vous devez mettre votre code dans plusieurs répertoires imbriqués (<em>Zend</em> et <em>Mvc</em>).</p>
<p>Pour résoudre ce problème, le PSR-4 vous permet de définir une série contiguë d'un ou plusieurs namespaces
et sous-namespaces correspondants à un "répertoire de base". Par exemple, si vous avez le nom de classe
complet <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/classes/Zend/Mvc/Application.html" class="api-link">\Zend\Mvc\Application</a></code>, et si vous définissez que <code><a target="_blank" href="https://olegkrivtsov.github.io/zf3-api-reference/html/components/zendframework/zend-mvc.html" class="api-link">\Zend\Mvc</a></code> correspond au répertoire
"/path/to/zendframework/zend-mvc/src", vous pouvez organisez vos fichiers comme suit:</p>
<pre class=""><code class="language-text">/path/to/zendframework/zend-mvc/src
    Application.php
</code></pre>
<p>Pour le code soit conforme à la norme PSR-4, nous pouvons écrire et déclarer un autoloader, que nous
appellerons l'autoloader "standard" :</p>
<pre class=""><code class="language-php">&lt;?php

// Fonction de chargement automatique "Standard".
function standardAutoloadFunc($className)
{
    // Remplace le préfixe du namespace par le répertoire de base.
    $prefix = '\\Zend\\Mvc';
    $baseDir = '/path/to/zendframework/zend-mvc/src/';
    if (substr($className, 0, strlen($prefix)) == $prefix) {
        $className = substr($className, strlen($prefix)+1);
        $className = $baseDir . $className;
    }

    // Remplace les séparateurs d'espace de noms dans le namespace par des séparateurs de répertoire.
    $className = str_replace('\\', DIRECTORY_SEPARATOR, $className);

    // Ajoute l'extension .php.
    $fileName = $className . ".php";

    // Vérifie si le fichier existe et est lisible.
    if (is_readable($fileName)) {
        // Inclus  le fichier.
        require $fileName;
    }
}

// Déclaration de la fonction d'autoloader.
spl_autoload_register("standardAutoloadFunc");
</code></pre>
<p>L'autoloader standard fonctionne comme suit. En supposant que le namespace des classes peut être mappé à
la structure des répertoires un par un, la fonction calcule le chemin vers le fichier PHP en transformant
les back-slashes (séparateurs de namespace) en forward slashes (séparateurs de chemin) et en concaténant
le chemin d'accès absolu au dossier où se trouve la bibliothèque.
Ensuite, la fonction vérifie si un tel fichier PHP existe vraiment, et si oui, l'inclut avec l'instruction
<code>require</code>.</p>
<p>Il est évident que l'autoloader standard fonctionne plus lentement que l'autoloader de class map.
Cependant, son avantage est que vous n'avez pas besoin de gérer une class map, ce qui est très pratique
lorsque vous développez un nouveau code et ajoutez de nouvelles classes à votre application.</p>
<blockquote class="notquote information" data-type="information"><p> Zend Framework 3 est conforme à la norme PSR-4, ce qui permet d'utiliser un mécanisme d'autoloading
 standard sur tous ses composants. Il est également compatible avec d'autres librairies conformes au PSR-4
 comme Doctrine ou Symfony.</p>
</blockquote><h3 id="L_Autoloader_fournis_par_Composer">3.4.3. L'Autoloader fournis par Composer</h3>
<p>Composer peut générer des fonctions d'autoloading (à la fois des autoloaders de class map et des
autoloader norme PSR-4) pour le code que vous installez avec.
Zend Framework 3 utilise l'autoloader fournie par Composer.
Lorsque vous installez un package avec Composer, il crée automatiquement le fichier
<em>APP_DIR/vendor/autoload.php</em>, qui utilise la fonction PHP <code>spl_autoload_register()</code> pour déclarer
un autoloader. De cette façon, toutes les classes PHP situées dans le répertoire <code>APP_DIR/vendor</code>
sont chargées automatiquement.</p>
<p>Pour charger automatiquement les classes PHP situées dans vos propres modules (comme le module <code>Application</code>),
vous devez spécifier la clé <code>autoload</code> dans votre fichier <code>composer.json</code> :</p>
<pre class=""><code class="language-json",title="Autoload key of composer.json file">"autoload": {
    "psr-4": {
        "Application\\": "module/Application/src/"
    }
},
</code></pre>
<p>Ensuite, la seule chose à faire est d'inclure ce fichier dans votre script d'entrée <code>index.php</code> :</p>
<pre class=""><code class="language-php">// Composer autoloading
include __DIR__ . '/../vendor/autoload.php';
</code></pre>
<blockquote class="notquote tip" data-type="tip"><p> Le fichier <em>autoload.php</em> est généré chaque fois que vous installez un package avec Composer.
 Au besoin, pour que Composer génère le fichier autoload.php, vous pourrez exécuter la commande
 <code>dump-autoload</code> :</p>
<p> <code>php composer.phar dump-autoload</code></p>
</blockquote><h3 id="PSR_4_et_la_structure_du_répertoire_source_du_module">3.4.4. PSR-4 et la structure du répertoire source du module</h3>
<p>Dans Zend Skeleton Application, vous pouvez voir comment la norme PSR-4 est appliquée dans la pratique.
Pour le module par défaut de votre site Web, le module <code>Application</code>, les classes PHP déclarées avec
l'autoloader standard sont stockées dans le répertoire <code>APP_DIR/module/Application/src</code> ("src" abréviation
de "source").</p>
<blockquote class="notquote information" data-type="information"><p> Nous ferons référence au répertoire <code>src</code> en tant que répertoire source du module.</p>
</blockquote><p>Par exemple, regardons le fichier <code>IndexController.php</code> du module <code>Application</code> (figure 3.2).</p>
<p><span class="image-wrapper">
<a target="_blank" href="../../en/images/operation/psr0_and_dir_structure.png">
<img src="../../en/images/operation/psr0_and_dir_structure.png" alt="Figure 3.2. La structure du répertoire de l'application squelette est conforme à la norme PSR-4" /></a>
<span class="image-caption">Figure 3.2. La structure du répertoire de l'application squelette est conforme à la norme PSR-4</span>
</span>
</p>
<p>Comme vous pouvez le voir, il contient la classe <code>IndexController</code> <sup id="fnref:controller"><a href="#fn:controller" class="footnote-ref" rel="footnote">1</a></sup> appartenant à l'espace de
noms <code>Application\Controller</code>. Pour pouvoir suivre la norme PSR-4 et utiliser l'autoloader standard avec
cette classe PHP, nous devons le placer dans le dossier <code>Controller</code> du dossier source du module.</p>
<footnotes id="fn:controller"><p><sup>1)</sup> La classe <code>IndexController</code> est le contrôleur par défaut de l'application squelette.
Nous parlerons des contrôleurs plus loin dans le chapitre <a  href="../Modèle_Vue_Controleur.html">Model-View-Controller</a>.</p>
</footnotes>
        
</div>

<!-- Ads -->
<div id="ads-chapter-bottom">
<div>
﻿<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Using Zend Framework 3 Chapter - Bottom - Adaptive -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3933778336056438"
     data-ad-slot="1546211126"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
</div>
    
<!-- Navigation -->
<div class="navigation">
        <div class="current-chapter">
        <a href="../Fonctionnement_d_un_site.html">
            <img alt="Contents" src="../../assets/images/upload.png"><span class="nav-btn-text">Fonctionnement d'un site</span>
        </a>
    </div>
        <div class="prev-chapter">
        
        <a href="../Fonctionnement_d_un_site/Les_Interfaces_PHP.html">
            <img alt="Previous Chapter" src="../../assets/images/left.png"><span class="nav-btn-text">Previous</span>
        </a>
        </div>    
    <div class="contents">
        <a href="../toc.html">
            <img alt="Contents" src="../../assets/images/book.png"><span class="nav-btn-text">Contents</span>
        </a>
    </div>
    <div class="next-chapter">
                <a href="../Fonctionnement_d_un_site/Requête_et_Réponse_HTTP.html">
            <span class="nav-btn-text">Next</span><img alt="Next Chapter" src="../../assets/images/right.png">
        </a>
            </div>        
</div>

<div id="disqus_thread"></div>

        
</div>
<footer>
    <div class="footer">
        <div class="footer-body">
            <div class="copyright">
                Copyright &copy; 2019 by Oleg Krivtsov            </div>
            <div class="footer-menu">
                                <div class="footer-link">
                    <a href="https://olegkrivtsov.github.io/using-zend-framework-3-book/legal/terms-and-conditions.html">Terms &amp; Conditions</a>
                </div>
                                <div class="footer-link">
                    <a href="https://olegkrivtsov.github.io/using-zend-framework-3-book/legal/copyright-policy.html">Copyright Policy</a>
                </div>
                                <div class="footer-link">
                    <a href="https://olegkrivtsov.github.io/using-zend-framework-3-book/legal/privacy-policy.html">Privacy Policy</a>
                </div>
                            </div>
            <div class="generated-by">
                Generated using <a href="https://github.com/olegkrivtsov/openbook">OpenBook</a>
            </div>
        </div>    
    </div>
</footer>

<a href="#0" class="cd-top">Top</a>

<script src="../../assets/js/jquery.min.js"></script>
<script src="../../assets/js/loadCSS.js"></script>
<script src="../../assets/js/popup.js"></script>

<script src="../../assets/js/prism.js"></script>

<script>
var disqus_config = function () {
this.page.url = window.location.href; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = ''; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//using-zend-framework-3-book.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script>
loadCSS("../../assets/css/prism.css");
</script>

<script>
jQuery(document).ready(function($){
    // browser window scroll (in pixels) after which the "back to top" link is shown
    var offset = 300,
    //browser window scroll (in pixels) after which the "back to top" link opacity is reduced
    offset_opacity = 1200,
    //duration of the top scrolling animation (in ms)
    scroll_top_duration = 700,
    //grab the "back to top" link
    $back_to_top = $('.cd-top');

    //hide or show the "back to top" link
    $(window).scroll(function(){
            ( $(this).scrollTop() > offset ) ? $back_to_top.addClass('cd-is-visible') : $back_to_top.removeClass('cd-is-visible cd-fade-out');
            if( $(this).scrollTop() > offset_opacity ) { 
                    $back_to_top.addClass('cd-fade-out');
            }
    });

    //smooth scroll to top
    $back_to_top.on('click', function(event){
            event.preventDefault();
            $('body,html').animate({
                    scrollTop: 0 ,
                    }, scroll_top_duration
            );
    });

});
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-80824388-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>    

